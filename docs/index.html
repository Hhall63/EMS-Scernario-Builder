<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>EMT Scenario Dashboard</title>
<style>
  :root{ --bg:#f6f7f9; --fg:#111; --card:#fff; --muted:#6b7280; --b:#e5e7eb; --bb:#eef2f7;
         --primary:#2563eb; --green:#16a34a; --red:#dc2626; --amber:#f59e0b; --sticky-offset:0px; }
  *{box-sizing:border-box}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu; margin:0; background:var(--bg); color:var(--fg)}
  header{background:#1f2937;color:#fff;padding:12px 16px;display:flex;align-items:center;justify-content:space-between}
  header .title{font-weight:700}
  .wrap{display:grid;grid-template-columns:380px 1fr;gap:16px;padding:16px}
  .panel{background:var(--card);border:1px solid var(--b);border-radius:12px;box-shadow:0 1px 2px rgba(0,0,0,.05)}
  .panel > .content{border-radius:0 0 12px 12px;overflow:hidden}
  .panel h3{margin:0;padding:10px 12px;border-bottom:1px solid var(--bb);font-size:16px}
  .content{padding:12px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px}
  .three{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:10px}
button.btn{border:1px solid var(--b);background:#fafafa;border-radius:10px;padding:8px 10px;cursor:pointer}
button.primary{background:var(--primary);color:#fff;border-color:#1d4ed8}
button.success{background:var(--green);color:#fff;border-color:#12833b}
/* active treatment: black, bold text */
.btn.tx-on { color:#000 !important; font-weight:700; }
button.danger{background:var(--red);color:#fff;border-color:#b91c1c}
button.muted{opacity:.6;cursor:not-allowed}
/* Larger treatment buttons for better touch targets */
#tx-buttons .btn,
#p-tx-buttons .btn,
#p-nb-tx-buttons .btn{
  font-size:15px;
  padding:12px 16px;
  border-radius:12px;
}
/* Badge chip */
.badge{
  display:inline-flex;
  align-items:center;
  gap:6px;
  border:1px solid var(--b);
  background:#f9fafb;
  border-radius:999px;
  padding:4px 8px;
  font-size:12px;
  color:var(--fg);
}

/* Compact vital editor inside a Treatment card */
/* Compact vital editor: single-line rows */
.vital-rows{
  display:grid;
  gap:8px;
  margin-bottom:8px;
}
.vital-row{
  display:grid;
  grid-template-columns: 140px repeat(4, minmax(0,1fr)); /* Label | Δ/s | Target | Max | Min */
  gap:8px;
  align-items:center;
}
.vital-row.head{
  font-size:12px;
  color:var(--muted);
  font-weight:600;
}
.vital-row .vlabel{ font-weight:700; }
.vital-help{ font-size:12px; color:var(--muted); margin-top:4px; }



/* audio cue rows in build */
.audio-row{display:grid;grid-template-columns:1fr auto auto;gap:8px;align-items:center;margin-bottom:8px}
.audio-row .btn{white-space:nowrap}
.audio-name{font-size:12px;color:var(--muted)}
#p-audio-buttons{align-items:flex-start}
#p-audio-buttons .audio-btn-wrap{display:flex;flex-direction:column;align-items:center;gap:6px;min-width:120px}
#p-audio-buttons .audio-footnote{display:flex;flex-direction:column;align-items:center;gap:2px;text-align:center;font-size:12px;color:#111;line-height:1.3}
#p-audio-buttons .audio-footnote strong{font-weight:700}
#audio-list .a-volume-field{display:flex;align-items:center;gap:8px;flex:0 0 220px;min-width:200px}
#audio-list .a-volume-field .a-volume-label{font-size:12px;font-weight:600;color:#111}
#audio-list .a-volume-field .a-volume{flex:1}
#audio-list .a-volume-field .a-volume-value{min-width:44px;text-align:right;font-size:12px;color:var(--muted);font-variant-numeric:tabular-nums}

#inject-list{display:flex;flex-direction:column;gap:12px}
.row.inject-row{
  display:flex;
  flex-wrap:wrap;
  gap:12px;
  align-items:flex-start;
  padding:14px;
  border:1px solid var(--bb);
  border-radius:12px;
  background:var(--card);
}
.row.inject-row .badge{align-self:center}
.row.inject-row .inject-field{display:flex;flex-direction:column;gap:4px;flex:1 1 150px;min-width:150px}
.row.inject-row .name-field{flex:2 1 240px;min-width:240px}
.row.inject-row .duration-field,
.row.inject-row .hide-field{flex:1 1 120px;max-width:160px}
.row.inject-row .color-field{flex:0 0 auto}
.row.inject-row .tx-field{flex:1 1 220px;min-width:220px}
.row.inject-row .inject-field .label-title,
.row.inject-row .inj-beep-wrap .label-title{font-size:12px;font-weight:600;color:#111}
.row.inject-row input,
.row.inject-row select{width:100%;padding:6px 10px;border-radius:8px;font-size:14px}
.row.inject-row .kv{display:flex;align-items:center;gap:8px;flex-wrap:wrap;padding:8px 10px;border:1px solid var(--bb);border-radius:8px;background:#f9fafb}
.row.inject-row .kv button{white-space:nowrap}
.row.inject-row .until-group{flex:0 1 220px;min-width:200px}
.row.inject-row .until-group .label-title{display:block;color:var(--muted);font-size:11px;letter-spacing:.04em;text-transform:uppercase}
.row.inject-row .until-group .saved-time{font-size:12px;color:var(--muted);font-variant-numeric:tabular-nums}
.row.inject-row .inj-beep-wrap{display:flex;flex-wrap:wrap;align-items:flex-end;gap:10px;flex:1 1 360px;min-width:320px}
.row.inject-row .inj-beep-wrap label{display:flex;flex-direction:column;gap:4px;min-width:210px}
.row.inject-row .inj-beep-wrap button{align-self:flex-end}
.row.inject-row .switch{display:inline-flex;align-items:center;gap:6px}
.row.inject-row .start-next-field{flex:0 0 auto;align-self:center}
.row.inject-row .btn{padding:6px 12px;border-radius:8px}
.row.inject-row .btn.danger{margin-left:auto}
.row.inject-row .color-field input[type="color"]{padding:0;height:32px;width:48px;border-radius:6px}
@media (max-width:1280px){
  .row.inject-row{gap:10px}
  .row.inject-row .inj-beep-wrap{min-width:0;flex:1 1 100%;align-items:flex-start}
  .row.inject-row .inj-beep-wrap label{min-width:180px}
  .row.inject-row .btn.danger{margin-left:0}
}


  .switch{display:inline-flex;align-items:center;gap:6px}
  textarea, input[type="text"], input[type="number"], select{width:100%;padding:8px;border-radius:10px;border:1px solid var(--b);background:#fff}
  .kv{border:1px solid var(--b);border-radius:10px;padding:10px}
 /* MONITOR COMPACT */
 .monitor{
    display:grid;
    gap:8px;                          /* tighter gutters */
    grid-template-columns:repeat(4,minmax(0,1fr));  /* more columns = less height */
    align-items:start;
 }
 @media (min-width:1280px){
  .monitor{ grid-template-columns:repeat(6,minmax(0,1fr)); }
 }
 @media (max-width:900px){
  .monitor{ grid-template-columns:repeat(3,minmax(0,1fr)); }
 }
 /* Force 6-up monitor all the time (stretch wide) */
.monitor{ grid-template-columns:repeat(6,minmax(0,1fr)) }
/* TREATMENTS FULL-WIDTH ROW */
#p-tx-buttons.row.wide{display:flex;flex-wrap:wrap;gap:8px;justify-content:flex-start;width:100%}
#p-tx-buttons.row.wide .btn{flex:0 1 auto}
 /* MONITOR COMPACT: smaller desc rows */
.subdesc{font-size:11px;color:#374151;margin-top:2px;line-height:1.2}
/* MONITOR COMPACT: denser cards and numbers */
.kv.compact{padding:6px 8px}
.kv.compact .v{font-size:20px;line-height:1.1;margin-top:2px}
/* Base cards (non-compact) */
.monitor .kv{padding:8px}                 /* was 10px globally */
.monitor .kv > div:first-child{           /* small title like HR, RR */
  font-size:14px;
  margin-bottom:2px;
}
.monitor .kv .v{                          /* the big value line */
  font-size:22px;                         /* smaller than default */
  line-height:1.1;
}

  .muted{color:var(--muted);font-size:12px}
  .divider{height:1px;background:var(--bb);margin:10px 0}
  .log{height:120px;overflow:auto;background:#0b1020;color:#c7d2fe;border-radius:10px;padding:10px;font-family:ui-monospace,monospace}
  .stickybar{position:-webkit-sticky;position:sticky;top:var(--sticky-offset,0px);background:#fff;border-bottom:1px solid var(--bb);padding:12px 16px;z-index:5}
  .stickybar.build-header{display:flex;flex-wrap:wrap;align-items:center;gap:12px 16px}
  .stickybar.build-header > *{flex:1 1 100%;min-width:0}
  .build-header__note{display:flex;flex-direction:column;gap:4px}
  .build-header__controls{display:flex;flex-wrap:wrap;gap:8px;justify-content:center}
  .build-header__timers{display:flex;flex-wrap:wrap;gap:16px;align-items:center;justify-content:flex-start}
  .build-header__timers .timer-wrap{min-width:140px}
  .build-header__timers .eta-input{min-width:160px}
  @media (min-width:1100px){
    .stickybar.build-header > *{flex:1 1 auto}
    .build-header__note{flex:1 1 240px}
    .build-header__controls{justify-content:center;flex:0 1 auto}
    .build-header__timers{justify-content:flex-end;flex:1 1 260px}
  }
  /* timers with captions + wider spacing */
  .timer-wrap{display:flex;flex-direction:column;align-items:center;min-width:160px}
  .eta-wrap{gap:6px}
  .eta-wrap .eta-pill{font-size:20px;padding:8px 16px;font-weight:600}
  .timer-caption{font-size:14px;color:#000;font-weight:700;margin-top:2px}
  .stickybar .note-start{font-size:14px;font-weight:700;color:#000}
  .stickybar.row{justify-content:center;gap:32px}          /* extra space between clocks */
  /* make inject timer match main timer size */
  #inject-counts .pill.inject-big{font-size:40px;padding:6px 12px;font-weight:700}
  /* STICKY BAR CENTER + SIZING */
    .stickybar.sticky-center{justify-content:center; gap:12px}
    .stickybar .bigbtn{font-size:16px; padding:10px 14px}   /* slightly larger */
    #inject-counts .pill.inject-big{font-size:40px; padding:6px 12px; font-weight:700} /* match main timer size */
  label.eta-input{display:flex;flex-direction:column;gap:4px;font-size:12px;color:#374151;min-width:160px}
  label.eta-input input{font-size:16px;font-weight:600;text-align:center;padding:6px 10px}
  /* HIDE ALS UI (BUILD + PLAY) */
#als-badge, #p-als-badge{ display:none !important; }          /* badges */
#flag-als-play, #flag-als-build{ display:none !important; }    /* checkboxes */
#flag-als-play + span, #flag-als-build + span{ display:none !important; } /* their label text */
    .als-on{background:#dcfce7;color:#065f46;border:1px solid #16a34a;padding:4px 8px;border-radius:999px}
  .big-timer{font-family:ui-monospace,monospace;font-size:40px;letter-spacing:1px}
  .hidden{display:none}
  .pill{padding:3px 8px;border-radius:999px;background:#eef2ff;color:#3730a3;font-size:12px;border:1px solid var(--b)}
  .stack{display:flex;flex-wrap:wrap;gap:6px}
  .mini{font-size:11px;color:var(--muted)}
  .mini.status-info{color:var(--muted)}
  .mini.status-success{color:var(--green)}
  .mini.status-error{color:var(--red)}
  .mini.status-warning{color:var(--amber)}
  button.btn[disabled]{opacity:.5;cursor:not-allowed}
  .help{font-size:12px;color:#374151}
  .error{color:#b91c1c;font-size:12px}
  /* Lung sounds header row + buttons */
  .ls-head{
    display:flex;
    align-items:center;
    gap:10px;          /* space between title and Stop/Loop */
    margin-bottom:10px;/* <— a touch more space before the lung sound buttons */
  }
  .ls-head h3{ border:none; padding:0; margin:0; }

  /* Single large inject pill in the PLAY bar */
#inject-counts .pill.inject-big{font-size:28px;padding:10px 18px;font-weight:700}
#inject-counts .pill.active{background:#fee2e2} /* red when active */

/* Collapsible cards */
.kv .hdr{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.kv .body{margin-top:8px}
/* Inline selector groups inside a Treatment card */
.inline-line{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
.inline-line .group-h{font-weight:700; min-width:64px}
.inline-line label{display:flex;align-items:center;gap:6px;margin:0}
.inline-line select{min-width:140px}
/* Inline selector groups inside a Treatment card */
.inline-line{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
.inline-line .group-h{font-weight:700; min-width:64px}
.inline-line label{display:flex;align-items:center;gap:6px;margin:0}
.inline-line select{min-width:140px}
.kv.collapsed .body{display:none}
  /* Arrow toggle button for Treatments */
.icon-btn{background:transparent;border:0;cursor:pointer;padding:4px 6px;font-size:16px;line-height:1}
.icon-btn:focus{outline:2px solid var(--primary);outline-offset:2px}
/* PLAY: text sizing and two-column SAMPLE + OPQRST with divider */
.kv .hdr{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.kv .body{margin-top:8px}
.kv.collapsed .body{display:none}
.icon-btn{background:transparent;border:0;cursor:pointer;padding:4px 6px;font-size:16px;line-height:1}

details.builder-section{margin-bottom:16px;padding:12px;border:1px solid var(--bb);border-radius:10px;background:#fafbff}
details.builder-section summary{list-style:none;display:flex;align-items:center;gap:12px;font-weight:600;cursor:pointer}
details.builder-section summary::-webkit-details-marker{display:none}
details.builder-section summary::marker{display:none}
details.builder-section[open] summary{border-bottom:1px solid var(--bb);padding-bottom:6px;margin-bottom:12px}
details.builder-section .section-body{display:grid;gap:12px}
details.builder-section summary:focus-visible{outline:2px solid var(--primary);outline-offset:4px;border-radius:8px}
details.builder-section summary .section-toggle{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width:28px;
  height:28px;
  border-radius:6px;
  border:1px solid transparent;
  background:transparent;
  color:var(--muted);
  font-size:16px;
  transition:background .15s ease,color .15s ease,border-color .15s ease;
}
details.builder-section summary .section-toggle:hover,
details.builder-section summary .section-toggle:focus-visible{
  background:rgba(37,99,235,.08);
  border-color:rgba(37,99,235,.2);
  color:var(--primary);
  outline:none;
}
details.builder-section summary .section-toggle.is-open{color:var(--primary)}
details.builder-section summary .section-toggle .chevron{display:inline-block;line-height:1}
.display-toggle{font-size:12px;color:var(--muted);display:flex;align-items:center;gap:6px}
details.builder-section summary > .display-toggle{margin-left:auto}
.display-toggle input{accent-color:var(--primary)}
.display-toggle-row{display:flex;flex-wrap:wrap;gap:10px;margin-left:auto}

.build-section-actions{
  display:flex;
  flex-wrap:wrap;
  justify-content:flex-end;
  gap:8px;
  margin-bottom:12px;
}

.two-col{display:grid;grid-template-columns:1fr 1fr;gap:16px}
.ancillary-row{display:grid;gap:12px;margin-bottom:12px}
@media (min-width:720px){
  .ancillary-row{grid-template-columns:minmax(0,1fr) minmax(220px,1fr)}
}
.tx-log{display:flex;flex-direction:column;gap:8px;border:1px solid var(--bb);border-radius:10px;background:#f9fafb}
.tx-log-header{display:grid;grid-template-columns:minmax(0,1fr) auto auto;font-size:12px;font-weight:600;color:#4b5563;text-transform:uppercase;letter-spacing:.04em}
.tx-log-entry{display:grid;grid-template-columns:minmax(0,1fr) auto auto;gap:8px;align-items:center;font-size:14px;padding:6px 0;border-top:1px solid var(--bb)}
.tx-log-entry:first-of-type{border-top:0;padding-top:0}
.tx-log-label{font-weight:600}
.tx-log-start,.tx-log-elapsed{font-variant-numeric:tabular-nums}
.tx-log-entry--active .tx-log-elapsed{color:var(--green)}
.tx-log-empty{font-size:12px;color:var(--muted)}
/* Left column spacing for Physical under AVPU */
#p-physical{padding-top:4px}
.two-col .right{border-left:1px solid #000;padding-left:12px}

/* Slightly smaller SAMPLE to make room; black text, red initials */
#p-sample{font-size:1.3em;color:#111}

/* OPQRST matches SAMPLE */
#p-opqrst{font-size:1.3em;color:#111}

#p-sample strong,
#p-opqrst strong{
  color:var(--red);
  font-weight:700;
  font-size:1em !important;
  display:inline-block;
  width:2.1ch;       /* wider label block to prevent overlap */
  margin-right:.25em;/* extra gap between red label and black text */
}
/* Slightly smaller SAMPLE to make room; black text, red initials */
#p-sample{font-size:1.3em;color:#111}

/* Physical bullets and readable size like AVPU block */
#p-physical{font-size:16px;color:#111}
#p-physical ul{margin:6px 0 0 18px;padding:0}
#p-physical li{margin:2px 0}

/* APGAR horizontal layout */
#p-apgar-wrap .apgar-table-card{
  border:1px solid var(--b);
  border-radius:12px;
  background:#fff;
  padding:12px;
  display:grid;
  gap:10px;
}
#p-apgar-wrap .apgar-table{
  display:grid;
  gap:8px;
}
#p-apgar-wrap .apgar-header,
#p-apgar-wrap .apgar-row,
#p-apgar-wrap .apgar-footer{
  display:grid;
  gap:8px;
  grid-template-columns:minmax(180px,1.2fr) minmax(60px,.6fr) minmax(140px,1fr) minmax(60px,.6fr) minmax(140px,1fr);
  align-items:center;
}
#p-apgar-wrap .apgar-label{
  font-weight:600;
  color:#111;
}
#p-apgar-wrap .apgar-header{
  font-weight:700;
  border-bottom:1px solid var(--bb);
  padding-bottom:4px;
}
#p-apgar-wrap .apgar-footer{
  font-weight:700;
  border-top:1px solid var(--bb);
  padding-top:6px;
}
#p-apgar-wrap .apgar-score{
  text-align:center;
}
#p-apgar-wrap .apgar-note{
  font-size:14px;
  font-weight:700;
  color:#000;
  white-space:pre-wrap;
}

/* Flashing background for active treatment buttons */
@keyframes tflash { 
  0%,100% { background: var(--on, #16a34a); }
  50%     { background: var(--off, #fafafa); }
}
/* COUNTDOWN WARNING FLASH */
@keyframes warnFlash { 0%,100%{ background:transparent } 50%{ background:#fef3c7 } } /* amber */
.flash-warn{ animation: warnFlash .8s linear infinite; border-color:#f59e0b !important; }
.btn.tflash { animation: tflash .9s linear infinite; }
/* Brand logo in header */
header .title{
  display:flex;
  align-items:center;
  gap:10px;
}
#brand-logo{
  height:28px;   /* adjust if needed */
  width:auto;
  display:block;
}
/* Screen-reader-only text */
.sr-only{
  position:absolute;
  width:1px;height:1px;padding:0;margin:-1px;
  overflow:hidden;clip:rect(0 0 0 0);white-space:nowrap;border:0;
}
/* URGENT modal */
.modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:9999}
.modal.show{display:flex}
.modal-backdrop{position:absolute;inset:0;background:rgba(0,0,0,.35)}
.modal-card{position:relative;min-width:320px;max-width:720px;border-radius:12px;overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,.25)}
.modal-head{background:#dc2626;color:#000;font-weight:800;padding:12px 16px;font-size:18px}
.modal-body{background:#f3f4f6;color:#000;font-weight:700;font-size:20px;line-height:1.4;padding:18px}
.modal-actions{background:#f3f4f6;padding:12px 16px;display:flex;justify-content:flex-end}
.modal-actions .btn{background:#fff}
</style>
</head>
<body>
<header>
  <div class="title">© Redline Creations, LLC</div>

  <div>
    <span class="badge">Mode:</span>
    <button id="mode-build" class="btn">Build</button>
    <button id="mode-play" class="btn primary">Play</button>
    <button id="export" class="btn">Export JSON</button>
    <label id="import-label" class="badge" style="cursor:pointer" title="Click to select a file">
      Import JSON
      <input id="import" type="file" accept="application/json" style="display:none">
    </label>
    <span class="badge">Autosave: <span id="autosave">idle</span></span>
  </div>
</header>


<!-- BUILD -->
<div class="wrap" id="build">
  <div class="panel">
    <div class="stickybar build-header">
      <div class="build-header__note">
        <span class="note-start">Click start when student enters scenario room and sees the patient</span>
      </div>
      <div class="build-header__controls">
        <button id="start" class="btn success" style="font-size:15px">Start</button>
        <button id="pause" class="btn" style="font-size:15px">Pause</button>
        <button id="reset" class="btn danger" style="font-size:15px">Reset</button>
      </div>
      <div class="build-header__timers">
        <div class="timer-wrap">
          <div id="timer" class="big-timer">15:00</div>
          <div class="timer-caption">Scenario Time Remaining / ALS ETA</div>
        </div>
        <label class="eta-input">Hospital ETA
          <input id="txt-hospital-eta" type="text" placeholder="e.g. 12 min or 08:00">
        </label>
      </div>
    </div>
    <div class="content">
      <!-- Removed the left-side build Monitor preview as requested -->

      <div class="divider"></div>
      <h3>Treatments (preview)</h3>
      <div id="tx-buttons" class="row"></div>

      <div class="divider"></div>
      <h3>SAMPLE & Physical (preview)</h3>
      <div id="sample-preview" class="content muted"></div>

      <div class="divider"></div>
      <h3>Log</h3>
      <div id="log" class="log"></div>
    </div>
  </div>

  <div class="panel">
    <div class="content">
      <div class="build-section-actions">
        <button id="collapse-build-sections" type="button" class="btn">Collapse all sections</button>
      </div>

      <details class="builder-section" data-section="github" open>
        <summary>
          <span>GitHub Scenarios</span>
          <span class="mini" data-gh-status></span>
        </summary>
        <div class="section-body" id="github-scenarios">
          <div class="grid">
            <label>Owner / Org <input id="gh-owner" type="text" placeholder="e.g., county-ems"></label>
            <label>Repository <input id="gh-repo" type="text" placeholder="scenario-library"></label>
            <label>Branch <input id="gh-branch" type="text" value="main"></label>
            <label>Folder (optional) <input id="gh-path" type="text" placeholder="scenarios/med"></label>
          </div>
          <div class="grid">
            <label>Committer Name <input id="gh-committer-name" type="text" placeholder="EMS Scenario Builder"></label>
            <label>Committer Email <input id="gh-committer-email" type="email" placeholder="ems-scenarios@example.com"></label>
            <label>Token (classic or fine-grained) <input id="gh-token" type="password" autocomplete="off" placeholder="ghp_..."></label>
            <label>Scenario file name <input id="gh-filename" type="text" placeholder="my-scenario.json"></label>
          </div>
          <div class="row" style="align-items:flex-end; gap:12px; flex-wrap:wrap;">
            <label style="min-width:240px; flex:1 1 260px;">
              Remote scenarios
              <select id="gh-scenario-select" data-gh-select>
                <option value="">(none loaded)</option>
              </select>
            </label>
            <button id="gh-refresh" class="btn">Refresh list</button>
            <button id="gh-load" class="btn">Load selected</button>
            <button id="gh-save" class="btn primary">Save to GitHub</button>
          </div>
          <div class="help">
            Provide a personal access token with <code>repo</code> scope (fine-grained tokens need contents:read/write).
            The folder is optional; leave blank to use the repository root. Enter a scenario file name (or leave it blank
            to auto-slugify the title) and click <strong>Save to GitHub</strong> to create or update that file. Scenario
            files are stored as JSON just like the local export. The token is stored in this browser only.
          </div>
        </div>
      </details>

      <details class="builder-section" data-section="meta" open>
        <summary>
          <span>Meta</span>
        </summary>
        <div class="section-body">
          <div class="grid">
            <label>Title <input id="meta-title" type="text"></label>
            <label>Author <input id="meta-author" type="text"></label>
          </div>
        </div>
      </details>

      <div class="divider"></div>
      <details class="builder-section" data-section="text" open>
        <summary>
          <span>Text</span>
          <div class="display-toggle-row">
            <label class="display-toggle"><input type="checkbox" data-display-key="text" checked> Dispatch/Impression</label>
            <label class="display-toggle"><input type="checkbox" data-display-key="backstory" checked> Backstory</label>
            <label class="display-toggle"><input type="checkbox" data-display-key="talkingPoints" checked> Talking Points</label>
          </div>
        </summary>
        <div class="section-body">
          <div class="grid">
            <label>Dispatch <textarea id="txt-dispatch" rows="2"></textarea></label>
            <label>General Impression <textarea id="txt-gi" rows="2"></textarea></label>
          </div>
          <div class="grid">
            <label>AVPU <input id="txt-avpu" type="text"></label>
            <label>NOI/MOI <input id="txt-noi" type="text"></label>
            <label>C-spine <input id="txt-cspine" type="text"></label>
          </div>
          <div class="grid" id="backstory-fields">
            <label>Patient Backstory <textarea id="txt-backstory" rows="3" placeholder="One line per bullet"></textarea></label>
            <label>Inject talking points <textarea id="txt-talkingpoints" rows="3" placeholder="One line per bullet"></textarea></label>
          </div>
        </div>
      </details>


      <div class="divider"></div>
      <details class="builder-section" data-section="sample" open>
        <summary>
          <span>SAMPLE & Physical</span>
          <div class="display-toggle-row">
            <label class="display-toggle"><input type="checkbox" data-display-key="sample" checked> SAMPLE on Play</label>
            <label class="display-toggle"><input type="checkbox" data-display-key="physical" checked> Physical on Play</label>
          </div>
        </summary>
        <div class="section-body">
          <div class="grid">
            <label>S (Symptoms) <textarea id="s-s" rows="2" placeholder="Chief complaint and associated symptoms"></textarea></label>
            <label>A (Allergies) <textarea id="s-a" rows="2" placeholder="Drug, food, environmental"></textarea></label>
          </div>
          <div class="grid">
            <label>M (Medications) <textarea id="s-m" rows="2" placeholder="Name, dose, schedule, compliance"></textarea></label>
            <label>P (Pertinent history) <textarea id="s-p" rows="2" placeholder="Medical/surgical history, recent events"></textarea></label>
          </div>
          <div class="grid">
            <label>L (Last oral intake) <textarea id="s-l" rows="2" placeholder="Food/fluids, time, quantity"></textarea></label>
            <label>E (Events leading up) <textarea id="s-e" rows="2" placeholder="What happened, mechanism"></textarea></label>
          </div>
          <div class="grid">
            <label>Physical Findings <textarea id="phys" rows="3" placeholder="Focused assessment notes"></textarea></label>
          </div>
        </div>
      </details>

      <details class="builder-section" data-section="opqrst" open>
        <summary>
          <span>OPQRST</span>
          <label class="display-toggle"><input type="checkbox" data-display-key="opqrst" checked> Display on Play</label>
        </summary>
        <div class="section-body">
          <div class="grid">
            <label>O (Onset)        <textarea id="o-o" rows="2" placeholder="When it started, sudden/gradual"></textarea></label>
            <label>P (Provocation)  <textarea id="o-p" rows="2" placeholder="Better/worse with..."></textarea></label>
          </div>
          <div class="grid">
            <label>Q (Quality)      <textarea id="o-q" rows="2" placeholder="Sharp, dull, pressure..."></textarea></label>
            <label>R (Region/Rad.)  <textarea id="o-r" rows="2" placeholder="Where, does it travel"></textarea></label>
          </div>
          <div class="grid">
            <label>S (Severity)     <textarea id="o-s" rows="2" placeholder="0–10 or descriptive"></textarea></label>
            <label>T (Time)         <textarea id="o-t" rows="2" placeholder="Progression, duration"></textarea></label>
          </div>
        </div>
      </details>

      <div class="divider"></div>
      <details class="builder-section" data-section="audio" open>
        <summary>
          <span>Audio Cues</span>
        </summary>
        <div class="section-body">
          <div class="help">
            Add buttons that appear in Play mode. Upload or pick a sound, then use the
            auto-loop controls to start it when the run begins. Provide a duration,
            choose a treatment that ends the loop, or set both so the first condition wins.
          </div>
          <div id="audio-list"></div>
          <div class="row">
            <button id="add-audio" class="btn">Add audio cue</button>
          </div>
        </div>
      </details>

      <details class="builder-section" data-section="timing" open>
        <summary>
          <span>Timing</span>
        </summary>
        <div class="section-body">
          <div class="grid">
            <label>Countdown minutes <input id="min" type="number" min="1" value="15"></label>
          </div>
          <details open>
            <summary>Injects</summary>
            <div class="help">Time accepts <code>mm:ss</code>, <code>m:ss</code>, or seconds (e.g., <code>480</code>).</div>
            <div id="inject-list"></div>
            <div id="inj-error" class="error"></div>
            <div class="row">
              <label>Time <input id="inj-time" type="text" placeholder="12:30 or 480"></label>
              <label>Name <input id="inj-name" type="text" placeholder="Airway obstruction"></label>
              <button id="add-inject" class="btn">Add</button>
              <button id="apply-injects" class="btn primary">Apply to current run</button>
            </div>
          </details>
        </div>
      </details>

      <details class="builder-section" data-section="vitals" open>
        <summary>
          <span>Vitals</span>
        </summary>
        <div class="section-body">
          <div class="three">
            <label>HR <input id="v-hr" type="number" value="110"></label>
            <label>RR <input id="v-rr" type="number" value="26"></label>
            <label>SpO₂ <input id="v-spo2" type="number" step="0.1" value="88"></label>
            <label>SBP <input id="v-sbp" type="number" value="98"></label>
            <label>DBP <input id="v-dbp" type="number" value="62"></label>
            <label>CBG <input id="v-cbg" type="number" value="120"></label>
          </div>

          <div class="grid" style="margin-top:10px">
            <label>Pulse Rate <select id="v-hr-rate">
              <option value="normal">normal</option>
              <option value="tachycardic">tachycardic</option>
              <option value="bradycardic">bradycardic</option>
              <option value="absent">absent</option>
            </select></label>
            <label>Pulse Rhythm <select id="v-hr-rhythm">
              <option value="regular">regular</option>
              <option value="irregular">irregular</option>
              <option value="absent">absent</option>
            </select></label>
            <label>Pulse Quality <select id="v-hr-quality">
              <option value="normal">normal</option>
              <option value="weak">weak</option>
              <option value="thready">thready</option>
              <option value="bounding">bounding</option>
              <option value="absent">absent</option>
            </select></label>
          </div>

          <div class="grid">
            <label>Resp Rate <select id="v-rr-rate">
              <option value="normal">normal</option>
              <option value="tachypneic">tachypneic</option>
              <option value="bradypneic">bradypneic</option>
              <option value="absent">absent</option>
            </select></label>
            <label>Resp Rhythm <select id="v-rr-rhythm">
              <option value="regular">regular</option>
              <option value="irregular">irregular</option>
              <option value="absent">absent</option>
            </select></label>
            <label>Resp Quality <select id="v-rr-quality">
              <option value="normal">normal</option>
              <option value="shallow">shallow</option>
              <option value="labored">labored</option>
              <option value="absent">absent</option>
            </select></label>
          </div>

          <div class="grid">
            <label>Skin Color <select id="v-skin-color">
              <option value="normal">normal</option>
              <option value="pink">pink</option>
              <option value="pale">pale</option>
              <option value="flushed">flushed</option>
              <option value="cyanotic">cyanotic</option>
              <option value="mottled">mottled</option>
              <option value="jaundiced">jaundiced</option>
            </select></label>
            <label>Skin Temp <select id="v-skin-temp">
              <option value="warm">warm</option>
              <option value="hot">hot</option>
              <option value="cool">cool</option>
              <option value="cold">cold</option>
            </select></label>
            <label>Skin Moisture <select id="v-skin-moist">
              <option value="dry">dry</option>
              <option value="normal">normal</option>
              <option value="moist">moist</option>
              <option value="clammy">clammy</option>
              <option value="diaphoretic">diaphoretic</option>
            </select></label>
          </div>
        </div>
      </details>

      <details class="builder-section" data-section="treatments" open>
        <summary>
          <span>Treatments</span>
        </summary>
        <div class="section-body">
          <div id="tx-list"></div>
          <button id="add-tx" class="btn">Add Treatment</button>
          <p class="muted">Max caps per vital supported. Off toggles decay toward baseline.</p>
        </div>
      </details>

    </div>
  </div>
</div>

<!-- PLAY -->
<div class="wrap hidden" id="play">
  <div class="panel" style="grid-column:1 / -1">
<div class="stickybar row">
  <span class="note-start">Click start when student enters scenario room and sees the patient</span>
  <button id="p-start" class="btn success" style="font-size:15px">Start</button>
  <button id="p-pause" class="btn" style="font-size:15px">Pause</button>
  <button id="p-reset" class="btn danger" style="font-size:15px">Reset</button>

  <div class="timer-wrap">
    <div id="p-timer" class="big-timer">15:00</div>
    <div class="timer-caption">Scenario Time Remaining / ALS ETA</div>
  </div>

  <div class="timer-wrap eta-wrap">
    <button id="eta-pill" type="button" class="pill eta-pill" title="Time to hospital"></button>
    <div class="timer-caption">Time to hospital</div>
  </div>

  <div class="timer-wrap">
    <div id="inject-counts" class="stack"></div>
    <div class="timer-caption">Time To Inject</div>
  </div>
</div>
    <div class="content">
      <div id="play-text-section" class="grid">
        <div>
          <h3>Dispatch</h3>
          <div id="p-dispatch" class="content"></div>
        </div>
        <div>
          <h3>General Impression</h3>
          <div id="p-gi" class="content"></div>
        </div>
      </div>

     <div class="divider"></div>

<!-- AVPU + Physical (left) and SAMPLE/OPQRST (right) -->
<div class="grid">
  <div id="play-ancillary-section">
    <h3>AVPU / NOI-MOI / C-spine</h3>
    <div class="ancillary-row">
      <div id="p-ancillary" class="content"></div>
      <div id="p-treatment-log" class="content tx-log"></div>
    </div>

    <h3>Physical Exam Findings</h3>
    <div id="p-physical" class="content"></div>
  </div>

  <div id="play-sampleopqrst-section">
    <h3>SAMPLE & OPQRST</h3>
    <div class="content">
      <div class="two-col">
        <div id="p-sample-wrap" class="col left"><div id="p-sample"></div></div>
        <div id="p-opqrst-wrap" class="col right"><div id="p-opqrst"></div></div>
      </div>
    </div>
  </div>
</div>

<div class="kv">
  <div class="ls-head">
    <h3>Lung Sound Controls</h3>
    <button id="p-audio-stop" class="btn">Stop</button>
    <button id="p-audio-loop" class="btn">Loop: Off</button>
  </div>
  <div id="p-audio-buttons" class="row"></div>
  <audio id="p-audio" preload="auto" crossorigin="anonymous"></audio>
</div>

<h3>Monitor</h3>
<div class="monitor">
  <div class="kv"><div>HR</div><div class="v" id="p-hr">--</div><div id="p-hr-desc" class="subdesc"></div></div>
  <div class="kv"><div>RR</div><div class="v" id="p-rr">--</div><div id="p-rr-desc" class="subdesc"></div></div>
  <div class="kv compact"><div>SpO₂</div><div class="v" id="p-spo2">--</div></div>
  <div class="kv compact"><div>B/P</div><div class="v" id="p-bp">--/--</div></div>
  <div class="kv compact"><div>CBG</div><div class="v" id="p-cbg">--</div></div>
  <div class="kv compact"><div>Skin</div><div class="v" id="p-skin">--</div></div>
</div>

<h3>Treatments</h3>
<div id="p-tx-buttons" class="row wide"></div>

<script>
"use strict";
const BUILDER_INTERACTIVE_SELECTOR = 'button:not(.section-toggle), input, select, textarea, label, a';

function escapeAttr(value){
  return String(value ?? '')
    .replace(/&/g,'&amp;')
    .replace(/"/g,'&quot;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;');
}

function enhanceBuilderSections(root=document){
  const candidates = new Set();
  if (root && typeof root.querySelectorAll === 'function'){
    root.querySelectorAll('details.builder-section').forEach(node => candidates.add(node));
  }
  if (root && root.matches && root.matches('details.builder-section')){
    candidates.add(root);
  }
  const guardSummaryControls = (summary)=>{
    summary.querySelectorAll(BUILDER_INTERACTIVE_SELECTOR).forEach(ctrl => {
      if (ctrl.closest('.section-toggle')) return;
      if (ctrl.dataset.builderGuarded === '1') return;
      const stop = (event)=>event.stopPropagation();
      ctrl.addEventListener('click', stop);
      ctrl.addEventListener('pointerdown', stop);
      ctrl.dataset.builderGuarded = '1';
    });
  };
  candidates.forEach(details => {
    if (!details) return;
    const summary = details.querySelector(':scope > summary');
    if (!summary) return;
    guardSummaryControls(summary);
    if (summary.querySelector('.section-toggle')){
      details.dataset.sectionEnhanced = '1';
      return;
    }
    const toggle = document.createElement('button');
    toggle.type = 'button';
    toggle.className = 'section-toggle';
    const chevron = document.createElement('span');
    chevron.className = 'chevron';
    chevron.setAttribute('aria-hidden', 'true');
    toggle.appendChild(chevron);
    const hasControls = summary.querySelector('.display-toggle-row, .display-toggle');
    if (hasControls){
      toggle.style.marginLeft = '8px';
    }else{
      toggle.style.marginLeft = 'auto';
    }
    const syncState = ()=>{
      const open = !!details.open;
      toggle.classList.toggle('is-open', open);
      toggle.setAttribute('aria-expanded', open ? 'true' : 'false');
      toggle.setAttribute('aria-label', open ? 'Collapse section' : 'Expand section');
      chevron.textContent = open ? '▾' : '▸';
    };
    toggle.addEventListener('click', event => {
      event.preventDefault();
      event.stopPropagation();
      details.open = !details.open;
      syncState();
    });
    details.addEventListener('toggle', syncState);
    summary.appendChild(toggle);
    syncState();
    details.dataset.sectionEnhanced = '1';
  });
}

window.enhanceBuilderSections = enhanceBuilderSections;
enhanceBuilderSections(document.getElementById('build') || document);
const collapseBuildSectionsBtn = document.getElementById('collapse-build-sections');
if (collapseBuildSectionsBtn){
  collapseBuildSectionsBtn.addEventListener('click', ()=>{
    document.querySelectorAll('#build details.builder-section').forEach(section => {
      if (section.open){
        section.open = false;
      }
    });
  });
}
const te = new TextEncoder(), td = new TextDecoder();
const GH_CONFIG_KEY = 'emtScenarioGithubConfigV1';
const githubState = { items: [], lastSelected: '' };

const rootElement = document.documentElement;
const pageHeader = document.querySelector('header');
const STICKY_OFFSET_VAR = '--sticky-offset';
let stickyOffsetFrame = null;

function applyStickyOffset(){
  if (!pageHeader || !rootElement) return;
  const { bottom } = pageHeader.getBoundingClientRect();
  const offset = Math.max(bottom, 0);
  rootElement.style.setProperty(STICKY_OFFSET_VAR, `${offset}px`);
}

function scheduleStickyOffset(){
  if (stickyOffsetFrame !== null) return;
  stickyOffsetFrame = requestAnimationFrame(() => {
    stickyOffsetFrame = null;
    applyStickyOffset();
  });
}

applyStickyOffset();
window.addEventListener('scroll', scheduleStickyOffset, { passive: true });
window.addEventListener('resize', scheduleStickyOffset);

function scenarioSelects(){
  return Array.from(document.querySelectorAll('[data-gh-select]'));
}

function setScenarioSelectValue(value){
  const paths = new Set(githubState.items.map(item => item.path));
  scenarioSelects().forEach(select => {
    const target = value && paths.has(value) ? value : '';
    const hasOption = Array.from(select.options).some(opt => opt.value === target);
    select.value = hasOption ? target : '';
  });
}

function setGitHubStatus(message, mode='info'){
  const modes=['info','success','error','warning'];
  document.querySelectorAll('[data-gh-status]').forEach(el => {
    el.textContent = message || '';
    modes.forEach(name=>{
      el.classList.toggle(`status-${name}`, mode === name);
    });
    el.classList.toggle('error', mode === 'error');
  });
}

function setGitHubBusy(isBusy, opts={}){
  const options = { save:true, load:true, refresh:true, select:true, ...opts };
  const toggle=(id, disabled)=>{
    const el = byId(id);
    if (el){
      el.disabled = !!disabled;
    }
  };
  if (options.save) toggle('gh-save', isBusy);
  if (options.load) toggle('gh-load', isBusy);
  if (options.refresh) toggle('gh-refresh', isBusy);
  if (options.select){
    scenarioSelects().forEach(sel => {
      sel.disabled = !!isBusy;
    });
  }
}

function renderPresetButtons(){
  const selects = scenarioSelects();
  if (!selects.length) return;
  const hasLast = githubState.items.some(item => item.path === githubState.lastSelected);
  selects.forEach(select => {
    const prev = githubState.lastSelected || select.value;
    select.innerHTML = '';
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = githubState.items.length ? 'Select a scenario…' : '(none found)';
    select.appendChild(placeholder);
    githubState.items.forEach(item => {
      const opt = document.createElement('option');
      opt.value = item.path;
      opt.textContent = item.displayName;
      select.appendChild(opt);
    });
    if (prev && githubState.items.some(item => item.path === prev)){
      select.value = prev;
    }else{
      select.value = '';
    }
  });
  if (!hasLast){
    githubState.lastSelected = '';
    rememberSelection('', byId('gh-filename')?.value?.trim() || '');
  }
}

function githubHeaders(token){
  const headers = { 'Accept': 'application/vnd.github+json', 'X-GitHub-Api-Version': '2022-11-28' };
  if (token) headers.Authorization = `Bearer ${token}`;
  return headers;
}

function encodeGitHubPath(path){
  if (!path) return '';
  return path.split('/').filter(Boolean).map(encodeURIComponent).join('/');
}

function getGitHubConfig(){
  const owner = byId('gh-owner')?.value?.trim() || '';
  const repo = byId('gh-repo')?.value?.trim() || '';
  const branch = byId('gh-branch')?.value?.trim() || 'main';
  const directory = (byId('gh-path')?.value || '').trim().replace(/^\/+|\/+$/g,'');
  const token = byId('gh-token')?.value?.trim() || '';
  const committerName = byId('gh-committer-name')?.value?.trim() || '';
  const committerEmail = byId('gh-committer-email')?.value?.trim() || '';
  return { owner, repo, branch, directory, token, committerName, committerEmail };
}

function persistGitHubConfig(config){
  try{
    localStorage.setItem(GH_CONFIG_KEY, JSON.stringify(config));
  }catch(err){
    console.warn('Unable to persist GitHub config', err);
  }
}

function hydrateGitHubConfig(){
  const raw = localStorage.getItem(GH_CONFIG_KEY);
  if (!raw) return;
  try{
    const cfg = JSON.parse(raw);
    const apply = (id, value) => { const el = byId(id); if (el && value != null) el.value = value; };
    apply('gh-owner', cfg.owner || '');
    apply('gh-repo', cfg.repo || '');
    apply('gh-branch', cfg.branch || '');
    apply('gh-path', cfg.directory || '');
    apply('gh-token', cfg.token || '');
    apply('gh-committer-name', cfg.committerName || '');
    apply('gh-committer-email', cfg.committerEmail || '');
    apply('gh-filename', cfg.lastFile || '');
    githubState.lastSelected = cfg.lastSelected || '';
  }catch(err){
    console.warn('Unable to read GitHub config', err);
  }
}

function rememberSelection(path, file){
  const current = getGitHubConfig();
  persistGitHubConfig({ ...current, lastSelected: path || '', lastFile: file || '' });
}

function validateGitHubConfig(config, opts={}){
  const options = { requireToken:true, ...opts };
  const missing = [];
  if (!config.owner) missing.push('owner/org');
  if (!config.repo) missing.push('repository');
  if (!config.branch) missing.push('branch');
  if (missing.length){
    return { valid:false, message:`Provide a GitHub ${missing.join(', ')}.` };
  }
  if (options.requireToken && !config.token){
    return { valid:false, message:'Add a GitHub token before saving scenarios.' };
  }
  const warning = !options.requireToken && !config.token
    ? 'Using unauthenticated requests. Private repositories require a token and rate limits will be lower.'
    : '';
  return { valid:true, warning };
}

function encodeScenarioContent(json){
  const bytes = te.encode(json);
  let binary = '';
  bytes.forEach(b => { binary += String.fromCharCode(b); });
  return btoa(binary);
}

function decodeScenarioContent(b64){
  const binary = atob(b64);
  const bytes = Uint8Array.from(binary, c => c.charCodeAt(0));
  return td.decode(bytes);
}

function scenarioForStorage(){
  const copy = JSON.parse(JSON.stringify(scenario));
  if (Array.isArray(copy.audios)){
    copy.audios.forEach(a=>{
      if (!a) return;
      delete a.data;
      delete a._objectUrl;
      if (a.url && a.url.startsWith('blob:')){
        delete a.url;
      }
    });
  }
  return copy;
}

function buildGitHubFilePath(config, filename){
  const parts = [];
  if (config.directory) parts.push(config.directory);
  if (filename) parts.push(filename);
  return encodeGitHubPath(parts.join('/'));
}

async function refreshGitHubScenarios(){
  const config = getGitHubConfig();
  const file = byId('gh-filename')?.value?.trim() || '';
  persistGitHubConfig({ ...config, lastSelected: githubState.lastSelected || '', lastFile: file });
  const check = validateGitHubConfig(config, { requireToken:false });
  if (!check.valid){
    setGitHubStatus(check.message, 'error');
    githubState.items = [];
    renderPresetButtons();
    return;
  }
  const statusMode = check.warning ? 'warning' : 'info';
  const owner = encodeURIComponent(config.owner);
  const repo = encodeURIComponent(config.repo);
  const dirPath = buildGitHubFilePath(config, '');
  const qs = new URLSearchParams({ ref: config.branch });
  const pathSegment = dirPath ? `contents/${dirPath}` : 'contents';
  const url = `https://api.github.com/repos/${owner}/${repo}/${pathSegment}?${qs.toString()}`;
  setGitHubBusy(true);
  if (check.warning){
    setGitHubStatus(`${check.warning} Loading scenarios from GitHub…`, 'warning');
  }else{
    setGitHubStatus('Loading scenarios from GitHub…', 'info');
  }
  try{
    const res = await fetch(url, { headers: githubHeaders(config.token) });
    if (res.status === 401 || res.status === 403){
      throw new Error('GitHub rejected the request. If this is a private repository, add a token with contents access.');
    }
    if (res.status === 404){
      githubState.items = [];
      renderPresetButtons();
      const message = 'No folder found at that path yet. Enter a file name and click Save to GitHub to create it.';
      setGitHubStatus(check.warning ? `${message} ${check.warning}` : message, statusMode);
      return;
    }
    if (!res.ok){
      const text = await res.text();
      throw new Error(`GitHub list failed: ${res.status} ${res.statusText} ${text}`);
    }
    const data = await res.json();
    const entries = Array.isArray(data) ? data : [data];
    const items = entries
      .filter(entry => entry.type === 'file' && entry.name.toLowerCase().endsWith('.json'))
      .map(entry => ({
        name: entry.name,
        displayName: entry.name.replace(/\.json$/i, ''),
        path: entry.path,
        sha: entry.sha
      }))
      .sort((a,b)=>a.displayName.localeCompare(b.displayName, undefined, { sensitivity:'base', numeric:true }));
    githubState.items = items;
    renderPresetButtons();
    if (!items.length){
      const base = 'No JSON scenario files found yet. Enter a file name and click Save to GitHub to create one.';
      setGitHubStatus(check.warning ? `${base} ${check.warning}` : base, statusMode);
    }else{
      const base = `Loaded ${items.length} scenario${items.length===1?'':'s'} from GitHub.`;
      const mode = check.warning ? 'warning' : 'success';
      setGitHubStatus(check.warning ? `${base} ${check.warning}` : `${base} Select a scenario or enter a new file name to create another.`, mode);
    }
  }catch(err){
    console.error(err);
    setGitHubStatus(err.message || 'Unable to load GitHub scenarios.', 'error');
  }finally{
    setGitHubBusy(false);
  }
}

async function saveScenarioToGitHub(){
  const config = getGitHubConfig();
  const fileInput = byId('gh-filename');
  let filename = (fileInput?.value || '').trim();
  if (!filename){
    const safeTitle = (scenario.meta?.title || 'scenario')
      .toLowerCase()
      .replace(/[^a-z0-9-_]+/g,'-')
      .replace(/-+/g,'-')
      .replace(/^-|-$/g,'');
    filename = (safeTitle || 'scenario') + '.json';
    if (fileInput) fileInput.value = filename;
  }
  if (!filename.toLowerCase().endsWith('.json')){
    filename = filename.replace(/\.+$/,'') + '.json';
    if (fileInput) fileInput.value = filename;
  }
  filename = filename.replace(/\s+/g,'-');
  if (fileInput) fileInput.value = filename;
  const check = validateGitHubConfig(config);
  if (!check.valid){
    setGitHubStatus(check.message, 'error');
    return;
  }
  persistGitHubConfig({ ...config, lastSelected: githubState.lastSelected || '', lastFile: filename });
  const owner = encodeURIComponent(config.owner);
  const repo = encodeURIComponent(config.repo);
  const filePath = buildGitHubFilePath(config, filename);
  const baseUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`;
  const qs = new URLSearchParams({ ref: config.branch });
  let sha;
  setGitHubBusy(true);
  try{
    try{
      const checkRes = await fetch(`${baseUrl}?${qs.toString()}`, { headers: githubHeaders(config.token) });
      if (checkRes.ok){
        const existing = await checkRes.json();
        sha = existing.sha;
      }else if (checkRes.status === 401 || checkRes.status === 403){
        throw new Error('GitHub rejected the request. Ensure your token has contents access for this repository.');
      }else if (checkRes.status !== 404){
        const text = await checkRes.text();
        throw new Error(`GitHub lookup failed: ${checkRes.status} ${checkRes.statusText} ${text}`);
      }
    }catch(err){
      throw new Error(err.message || 'Unable to check existing file on GitHub.');
    }
    setGitHubStatus('Saving scenario to GitHub…', 'info');
    save();
    const json = JSON.stringify(scenarioForStorage());
    const body = {
      message: `${sha ? 'Update' : 'Create'} scenario ${filename}`,
      content: encodeScenarioContent(json),
      branch: config.branch,
      committer: {
        name: config.committerName || 'EMS Scenario Builder',
        email: config.committerEmail || 'ems-scenarios@example.com'
      }
    };
    if (sha) body.sha = sha;
    const putRes = await fetch(baseUrl, {
      method: 'PUT',
      headers: { ...githubHeaders(config.token), 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });
    if (!putRes.ok){
      const text = await putRes.text();
      throw new Error(`GitHub save failed: ${putRes.status} ${putRes.statusText} ${text}`);
    }
    await putRes.json();
    const fullPath = (config.directory ? `${config.directory.replace(/\/+$/,'')}/` : '') + filename;
    githubState.lastSelected = fullPath;
    rememberSelection(fullPath, filename);
    setGitHubStatus('Scenario saved. Refreshing list…', 'info');
    await refreshGitHubScenarios();
    setScenarioSelectValue(githubState.lastSelected);
    setGitHubStatus(`Scenario saved to GitHub as ${fullPath}.`, 'success');
  }catch(err){
    console.error(err);
    setGitHubStatus(err.message || 'Unable to save scenario to GitHub.', 'error');
  }finally{
    setGitHubBusy(false);
  }
}

async function loadScenarioFromGitHub(){
  const config = getGitHubConfig();
  const check = validateGitHubConfig(config, { requireToken:false });
  if (!check.valid){
    setGitHubStatus(check.message, 'error');
    return;
  }
  const selects = scenarioSelects();
  const explicit = selects.find(sel => sel?.value)?.value || '';
  const path = githubState.lastSelected || explicit || '';
  if (!path){
    setGitHubStatus('Select a scenario from the dropdown first.', 'error');
    return;
  }
  const owner = encodeURIComponent(config.owner);
  const repo = encodeURIComponent(config.repo);
  const encodedPath = encodeGitHubPath(path);
  const url = `https://api.github.com/repos/${owner}/${repo}/contents/${encodedPath}?ref=${encodeURIComponent(config.branch)}`;
  setGitHubBusy(true, { save:false });
  if (check.warning){
    setGitHubStatus(`${check.warning} Loading scenario from GitHub…`, 'warning');
  }else{
    setGitHubStatus('Loading scenario from GitHub…', 'info');
  }
  try{
    const res = await fetch(url, { headers: githubHeaders(config.token) });
    if (res.status === 401 || res.status === 403){
      throw new Error('GitHub rejected the request. Add a token with contents access for private repositories.');
    }
    if (!res.ok){
      const text = await res.text();
      throw new Error(`GitHub load failed: ${res.status} ${res.statusText} ${text}`);
    }
    const data = await res.json();
    if (!data.content){
      throw new Error('GitHub response missing file content.');
    }
    const json = decodeScenarioContent(data.content);
    const obj = JSON.parse(json);
    scenario = obj;
    ensureScenarioDefaults();
    hydrateBuilderInputs();
    localStorage.setItem('emtScenarioRunnerV27', JSON.stringify(scenario));
    load();
    githubState.lastSelected = path;
    rememberSelection(path, byId('gh-filename')?.value?.trim() || '');
    setScenarioSelectValue(path);
    const base = `Loaded scenario from GitHub: ${path}`;
    setGitHubStatus(check.warning ? `${base}. ${check.warning}` : base, 'success');
  }catch(err){
    console.error(err);
    setGitHubStatus(err.message || 'Unable to load scenario from GitHub.', 'error');
  }finally{
    setGitHubBusy(false);
  }
}

/* ---------------- Utilities ---------------- */
const byId = (id) => document.getElementById(id);
let toneContext = null;
function ensureToneContext(){
  if (toneContext && toneContext.state === 'closed') toneContext = null;
  if (!toneContext){
    const C = window.AudioContext || window.webkitAudioContext;
    if (!C) return null;
    toneContext = new C();
  }
  return toneContext;
}
function runToneWithContext(fn){
  const ctx = ensureToneContext();
  if (!ctx) return;
  const exec = () => {
    try{ fn(ctx); }catch{}
  };
  if (ctx.state === 'suspended' && typeof ctx.resume === 'function'){
    try{
      const maybe = ctx.resume();
      if (maybe && typeof maybe.then === 'function'){
        maybe.then(exec).catch(()=>exec());
        return;
      }
    }catch{}
  }
  exec();
}
(function installToneUnlock(){
  if (typeof document === 'undefined') return;
  const unlock = () => {
    const ctx = ensureToneContext();
    if (!ctx) return;
    if (ctx.state === 'suspended' && typeof ctx.resume === 'function'){
      try{ ctx.resume(); }catch{}
    }
  };
  const passiveOnce = { once:true, passive:true };
  document.addEventListener('pointerdown', unlock, passiveOnce);
  document.addEventListener('touchstart', unlock, passiveOnce);
  document.addEventListener('keydown', unlock, { once:true });
})();
const tone = (f=880,m=500)=>{
  runToneWithContext(ctx=>{
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.connect(g);
    g.connect(ctx.destination);
    o.type = 'sine';
    o.frequency.value = f;
    g.gain.value = 0.05;
    o.start();
    setTimeout(()=>{
      try{o.stop();}catch{}
      try{o.disconnect();}catch{}
      try{g.disconnect();}catch{}
    }, m);
  });
};
const fmt = (s) => {s=Math.max(0,s|0);const m=String(Math.floor(s/60)).padStart(2,"0"),n=String(s%60).padStart(2,"0");return m+":"+n};
const clamp=(n,a,b)=>Math.max(a,Math.min(b,n));
function parseTimeFlexible(s){
  if (s == null) return -1;
  s = String(s).trim();
  if (s === "") return -1;
  if (/^\d+$/.test(s)) return parseInt(s,10);
  const m = s.match(/^(\d{1,3})\s*:\s*([0-5]?\d)$/);
  if (!m) return -1;
  return parseInt(m[1],10)*60 + parseInt(m[2],10);
}
function safeOn(el, evt, fn){ if (el) el.addEventListener(evt, fn); }

function log(msg){
  const e = byId("log");
  if (e){ e.textContent += msg + "\n"; e.scrollTop = e.scrollHeight; }
}

function readFileAsDataURL(file){
  return new Promise((res,rej)=>{
    const r=new FileReader();
    r.onload=()=>res(r.result);
    r.onerror=rej;
    r.readAsDataURL(file);
  });
}

function getAudioSrc(a){
  // prefer runtime object URL, then normal url, then (legacy) data
  const raw = (a && (a._objectUrl || a.url || a.data)) || '';
  if (!raw) return '';
  const trimmed = String(raw).trim();
  if (!trimmed) return '';
  if (/^(?:blob:|data:|https?:|file:|\/\/|\/)/i.test(trimmed)){
    return trimmed;
  }
  const normalized = ensureLibraryPath(trimmed);
  if (normalized){
    return normalized;
  }
  const base = getAudioLibraryBase();
  return `${base}${trimmed.replace(/^\/+/, '')}`;
}

function sanitizeAudioBase(base){
  let clean = (base == null ? '' : String(base)).trim();
  if (!clean){
    clean = 'Sounds/';
  }
  clean = clean.replace(/\\/g,'/');
  if (/^[a-z][a-z0-9+.-]*:\/\//i.test(clean)){
    try{
      const url = new URL(clean, window.location.href);
      clean = url.href;
    }catch(err){
      console.warn('Audio base URL normalization failed:', err);
    }
  }else{
    clean = clean.replace(/^\.\/+/,'');
    clean = clean.replace(/\/{2,}/g,'/');
    if (!clean.startsWith('/')){
      clean = clean.replace(/^\/+/, '');
    }
  }
  if (!clean.endsWith('/')) clean += '/';
  return clean;
}

function guessAudioLibraryBases(){
  const guesses = [];
  const seen = new Set();
  const add = (value)=>{
    if (value == null) return;
    const normalized = sanitizeAudioBase(value);
    if (!seen.has(normalized)){
      seen.add(normalized);
      guesses.push(normalized);
    }
  };

  add('Sounds/');
  add('./Sounds/');
  add('docs/Sounds/');
  add('./docs/Sounds/');
  add('EMS-Scernario-Builder/docs/Sounds/');
  add('/EMS-Scernario-Builder/docs/Sounds/');

  try{
    const baseUrl = new URL('.', window.location.href);
    const path = baseUrl.pathname || '/';
    add(`${path}Sounds/`);
    if (!path.toLowerCase().includes('/docs/')){
      add(`${path}docs/Sounds/`);
    }
    const segments = path.split('/').filter(Boolean);
    if (segments.length){
      const repoName = segments[0];
      add(`${repoName}/docs/Sounds/`);
      add(`/${repoName}/docs/Sounds/`);
    }
  }catch(err){
    console.warn('Audio base detection failed:', err);
  }

  return guesses;
}

const AUDIO_LIBRARY_BASE_CANDIDATES = guessAudioLibraryBases();
let audioLibraryBase = sanitizeAudioBase(AUDIO_LIBRARY_BASE_CANDIDATES[0] || 'Sounds/');
const AUDIO_LIBRARY_EXTS = ['.mp3','.wav','.ogg','.m4a','.aac','.flac','.webm'];
let audioLibrary = [];
let audioLibraryLoaded = false;

function getAudioLibraryBase(){
  return sanitizeAudioBase(audioLibraryBase || 'Sounds/');
}

function audioLibraryDisplayBase(){
  const base = getAudioLibraryBase();
  if (/^[a-z][a-z0-9+.-]*:\/\//i.test(base)){
    try{
      const url = new URL(base, window.location.href);
      const path = (url.pathname || '/').replace(/\/+$/,'/');
      return path || '/';
    }catch(err){
      console.warn('Audio base display normalization failed:', err);
    }
  }
  return base;
}

function ensureLibraryPath(path, overrideBase){
  if (!path) return '';
  let clean = String(path).trim();
  if (!clean) return '';
  clean = clean.replace(/\\/g,'/');
  // drop query/hash
  clean = clean.split('#')[0];
  clean = clean.split('?')[0];
  // trim leading ./
  clean = clean.replace(/^\.\//,'');
  const base = sanitizeAudioBase(overrideBase || getAudioLibraryBase());
  const baseTrimmed = base.replace(/\/+$/,'');
  const baseLower = baseTrimmed.toLowerCase();
  const marker = `${baseLower}/`;
  if (/^[a-z][a-z0-9+.-]*:\/\//i.test(clean)){
    const lower = clean.toLowerCase();
    const idx = lower.lastIndexOf(marker);
    if (idx !== -1){
      clean = clean.slice(idx + marker.length);
    }else{
      try{
        const parsed = new URL(clean);
        clean = parsed.pathname || '';
      }catch{
        return '';
      }
    }
  }else{
    const lower = clean.toLowerCase();
    if (lower === baseLower) return '';
    const idx = lower.lastIndexOf(marker);
    if (idx !== -1){
      clean = clean.slice(idx + marker.length);
    }
  }
  clean = clean.replace(/^\/+/, '');
  if (!clean) return '';
  const parts = clean.split('/').filter(Boolean);
  if (!parts.length) return '';
  const joined = parts.join('/');
  return `${base}${joined}`;
}

function formatAudioDisplayName(audio){
  if (!audio) return '';
  if (audio.name) return audio.name;
  const src = getAudioSrc(audio);
  if (!src) return '';
  if (src.startsWith('blob:')) return 'Uploaded audio';
  const clean = src.split('?')[0].split('#')[0];
  const parts = clean.split('/');
  return decodeURIComponent(parts[parts.length-1] || clean);
}

function audioLibraryLabel(path){
  if (!path) return '';
  const base = getAudioLibraryBase();
  const trimmed = path.startsWith(base)
    ? path.slice(base.length)
    : path;
  return decodeURIComponent(trimmed || path);
}

function normalizeLibrarySelection(audio){
  if (!audio) return '';
  const fromUrl = ensureLibraryPath(getAudioSrc(audio));
  if (fromUrl && audioLibrary.includes(fromUrl)) return fromUrl;
  const name = audio.name;
  if (name){
    const lowered = name.toLowerCase();
    const match = audioLibrary.find(p=>p.toLowerCase().endsWith(`/${lowered}`));
    if (match) return match;
  }
  return '';
}

function populateAudioLibraryOptions(selectEl, audio){
  if (!selectEl) return;
  selectEl.innerHTML = '';
  const placeholder = document.createElement('option');
  placeholder.value = '';
  if (!audioLibraryLoaded){
    placeholder.textContent = 'Loading library…';
    placeholder.disabled = true;
    placeholder.selected = true;
    selectEl.appendChild(placeholder);
    selectEl.disabled = true;
    return;
  }
  if (!audioLibrary.length){
    const baseLabel = audioLibraryDisplayBase();
    placeholder.textContent = baseLabel
      ? `No audio files found in ${baseLabel}`
      : 'No audio files found';
    placeholder.disabled = true;
    placeholder.selected = true;
    selectEl.appendChild(placeholder);
    selectEl.disabled = true;
    return;
  }
  placeholder.textContent = 'Select from library…';
  selectEl.appendChild(placeholder);
  selectEl.disabled = false;
  const current = normalizeLibrarySelection(audio);
  audioLibrary.forEach(path=>{
    const opt = document.createElement('option');
    opt.value = path;
    opt.textContent = audioLibraryLabel(path) || path;
    if (path === current) opt.selected = true;
    selectEl.appendChild(opt);
  });
  if (!current) selectEl.value = '';
}

function populateStopTreatmentOptions(selectEl, selectedId){
  if (!selectEl) return;
  selectEl.innerHTML = '';
  const list = Array.isArray(scenario.treatments) ? scenario.treatments : [];
  const hasTreatments = list.length > 0;

  const none = document.createElement('option');
  none.value = '';
  none.textContent = hasTreatments
    ? 'None'
    : 'None (add treatments first)';
  selectEl.appendChild(none);

  if (!hasTreatments && !selectedId){
    selectEl.disabled = true;
    selectEl.title = 'Add treatments in the section below to enable this list.';
  } else {
    selectEl.disabled = false;
    selectEl.title = 'Choose a treatment that stops this auto-loop when activated';
  }

  let hasSelection = false;
  list.forEach(tx => {
    if (!tx || !tx.id) return;
    const opt = document.createElement('option');
    opt.value = tx.id;
    const label = tx.label && tx.label !== tx.id
      ? `${tx.label} (${tx.id})`
      : tx.id;
    opt.textContent = label;
    if (tx.id === selectedId){
      opt.selected = true;
      hasSelection = true;
    }
    selectEl.appendChild(opt);
  });

  if (selectedId && !hasSelection){
    const orphan = document.createElement('option');
    orphan.value = selectedId;
    orphan.textContent = `${selectedId} (missing)`;
    orphan.selected = true;
    selectEl.appendChild(orphan);
    selectEl.disabled = false;
  }

  if (!selectedId) selectEl.value = '';
}

function getAudioGitHubContexts(){
  const contexts = [];
  try{
    const raw = localStorage.getItem(GH_CONFIG_KEY);
    if (raw){
      const cfg = JSON.parse(raw);
      if (cfg && cfg.owner && cfg.repo){
        contexts.push({
          owner: cfg.owner,
          repo: cfg.repo,
          branch: cfg.branch || 'main',
          token: cfg.token || ''
        });
      }
    }
  }catch(err){
    console.warn('Audio GitHub context load failed:', err);
  }

  try{
    const host = window.location.hostname || '';
    if (/\.github\.io$/i.test(host)){
      const owner = host.split('.')[0];
      const segments = (window.location.pathname || '').split('/').filter(Boolean);
      if (segments.length){
        const repo = segments[0];
        const fingerprint = `${owner}/${repo}`;
        if (!contexts.some(ctx => `${ctx.owner}/${ctx.repo}` === fingerprint)){
          contexts.push({ owner, repo, branch:'main', token:'' });
        }
      }
    }
  }catch(err){
    console.warn('Audio GitHub context detection failed:', err);
  }

  return contexts;
}

function repoPathForAudioBase(base, repoName){
  let clean = sanitizeAudioBase(base);
  if (/^[a-z][a-z0-9+.-]*:\/\//i.test(clean)){
    try{
      const url = new URL(clean, window.location.href);
      clean = url.pathname || '';
    }catch(err){
      console.warn('Audio repo path normalization failed:', err);
    }
  }
  clean = clean.replace(/^https?:\/\/[^/]+/i, '');
  clean = clean.replace(/^\/+/, '').replace(/\/+$/,'');
  if (!clean) return 'docs/Sounds';
  let parts = clean.split('/').filter(Boolean);
  if (repoName){
    const idx = parts.indexOf(repoName);
    if (idx !== -1){
      parts = parts.slice(idx + 1);
    }
  }
  if (!parts.length) return 'docs/Sounds';
  if (parts[0].toLowerCase() !== 'docs'){
    parts.unshift('docs');
  }
  return parts.join('/');
}

function runtimeBaseForRepoPath(repoPath){
  const trimmed = (repoPath || '').replace(/^\/+|\/+$/g,'');
  if (!trimmed) return 'Sounds/';
  const parts = trimmed.split('/').filter(Boolean);
  if (!parts.length) return 'Sounds/';
  if (parts[0].toLowerCase() === 'docs'){
    const remainder = parts.slice(1).join('/');
    return remainder ? `${remainder.replace(/\/+$/,'')}/` : 'Sounds/';
  }
  return `${parts.join('/')}/`;
}

async function fetchGitHubDirectoryListing(context, repoPath){
  const files = [];
  let reachable = false;
  if (!context || !context.owner || !context.repo || !repoPath) return { files, reachable };
  const owner = encodeURIComponent(context.owner);
  const repo = encodeURIComponent(context.repo);
  const encodedPath = repoPath.split('/').filter(Boolean).map(encodeURIComponent).join('/');
  const qs = new URLSearchParams({ ref: context.branch || 'main' });
  const url = `https://api.github.com/repos/${owner}/${repo}/contents/${encodedPath}?${qs.toString()}`;
  const headers = typeof githubHeaders === 'function'
    ? githubHeaders(context.token)
    : (context.token ? { Authorization:`Bearer ${context.token}` } : {});
  try{
    const res = await fetch(url, { headers });
    if (res.status === 401 || res.status === 403){
      reachable = true;
      return { files, reachable };
    }
    if (res.status === 404){
      return { files, reachable };
    }
    if (!res.ok){
      reachable = true;
      const text = await res.text().catch(()=> '');
      console.warn('Audio GitHub listing failed:', res.status, res.statusText, text);
      return { files, reachable };
    }
    reachable = true;
    const data = await res.json();
    const entries = Array.isArray(data) ? data : [data];
    entries.forEach(entry => {
      if (entry && entry.type === 'file'){
        files.push(entry.path || `${repoPath}/${entry.name}`);
      }
    });
  }catch(err){
    console.warn('Audio GitHub directory fetch failed:', err);
  }
  return { files, reachable };
}

async function enumerateAudioLibraryForBase(candidate){
  const base = sanitizeAudioBase(candidate);
  let bestBase = base;
  const seen = new Set();
  let reachable = false;
  const addPath = (value, overrideBase)=>{
    const targetBase = sanitizeAudioBase(overrideBase || bestBase);
    const normalized = ensureLibraryPath(value, targetBase);
    if (!normalized) return;
    if (normalized.includes('..')) return;
    if (!AUDIO_LIBRARY_EXTS.some(ext=>normalized.toLowerCase().endsWith(ext))) return;
    seen.add(normalized);
    bestBase = targetBase;
  };

  try{
    const res = await fetch(`${base}manifest.json`, { cache:'no-store' });
    if (res.ok){
      reachable = true;
      const data = await res.json();
      const entries = Array.isArray(data?.files) ? data.files : Array.isArray(data) ? data : [];
      entries.forEach(entry => addPath(entry));
    }else if (res.status && res.status !== 404){
      reachable = reachable || (res.status >= 200 && res.status < 500);
    }
  }catch(err){
    console.warn('Audio manifest load failed:', err);
  }

  if (!seen.size){
    try{
      const res = await fetch(base, { cache:'no-store' });
      if (res.ok){
        reachable = true;
        const text = await res.text();
        const doc = new DOMParser().parseFromString(text, 'text/html');
        Array.from(doc.querySelectorAll('a')).forEach(a=> addPath(a.getAttribute('href') || ''));
      }else if (res.status && res.status !== 404){
        reachable = reachable || (res.status >= 200 && res.status < 500);
      }
    }catch(err){
      console.warn('Audio directory listing failed:', err);
    }
  }

  if (!seen.size){
    const contexts = getAudioGitHubContexts();
    for (const ctx of contexts){
      const repoPath = repoPathForAudioBase(base, ctx.repo);
      const { files, reachable: ctxReachable } = await fetchGitHubDirectoryListing(ctx, repoPath);
      if (ctxReachable) reachable = true;
      if (files.length){
        const runtimeBase = runtimeBaseForRepoPath(repoPath);
        files.forEach(file => addPath(file, runtimeBase));
        break;
      }
    }
  }

  return { base: bestBase, seen, reachable };
}

async function loadAudioLibrary(){
  const candidates = AUDIO_LIBRARY_BASE_CANDIDATES.length
    ? AUDIO_LIBRARY_BASE_CANDIDATES
    : [getAudioLibraryBase()];
  const results = [];
  let winner = null;
  let reachableFallback = null;

  for (const candidate of candidates){
    const result = await enumerateAudioLibraryForBase(candidate);
    results.push(result);
    if (result.seen.size){
      winner = result;
      break;
    }
    if (!reachableFallback && result.reachable){
      reachableFallback = result;
    }
  }

  if (!winner){
    winner = reachableFallback || results[0] || { base: getAudioLibraryBase(), seen: new Set(), reachable:false };
  }

  audioLibraryBase = sanitizeAudioBase(winner.base || getAudioLibraryBase());
  audioLibrary = Array.from(winner.seen).sort((a,b)=>a.localeCompare(b, undefined, { sensitivity:'base' }));
  audioLibraryLoaded = true;
  try{ drawAudioEditor(); }catch{}
}

/* ---------------- Scenario model ---------------- */
const DEFAULT_SCENARIO = {
  meta:{title:"Scenario name",version:1,author:""},
  text:{
    dispatch:"",gi:"",avpu:"",noi:"",cspine:"",
    backstory:"",talkingPoints:"",
    hospitalEta:"—"
  },
  flags:{als:false},
  timing:{minutes:15},
  injects:[],
  vitals:{
    hr:110,rr:26,spo2:88,sbp:98,dbp:62,cbg:120,
    skinColor:"normal", skinTemp:"warm", skinMoist:"dry",
    hrRate:"normal", hrRhythm:"regular", hrQuality:"normal",
    rrRate:"normal", rrRhythm:"regular", rrQuality:"normal"
  },
  sample:{s:"",a:"",m:"",p:"",l:"",e:"",phys:""},
  opqrst:{o:"",p:"",q:"",r:"",s:"",t:""},
  audios:[],
  treatments:[],
  prompts:[],
  apgar:{
    one:{appearance:0,pulse:0,grimace:0,activity:0,respiration:0},
    five:{appearance:0,pulse:0,grimace:0,activity:0,respiration:0}
  },
  apgarNotes:{
    one:{appearance:"",pulse:"",grimace:"",activity:"",respiration:""},
    five:{appearance:"",pulse:"",grimace:"",activity:"",respiration:""}
  },
  nbVitals:{
    hr:140, rr:40, spo2:92, sbp:65, dbp:40, cbg:60,
    skinColor:"pink", skinTemp:"warm", skinMoist:"normal",
    hrRate:"normal", hrRhythm:"regular", hrQuality:"normal",
    rrRate:"normal", rrRhythm:"regular", rrQuality:"normal"
  },
  nbTreatments:[],
  displayOnPlay:{
    text:true,
    sample:true,
    opqrst:true,
    physical:true,
    backstory:true,
    talkingPoints:true,
    apgar:true,
    nbVitals:true,
    nbTreatments:true
  }
};

let scenario = JSON.parse(JSON.stringify(DEFAULT_SCENARIO));

/* ---------------- Runtime state ---------------- */
let currentAudioIdx = -1; // which audio button is currently playing (-1 = none)
let running=false, interval=null, tLeft=0, elapsed=0;
let audioLoop = false;
let autoLoopTimer = null;
let autoLoopIndex = -1;
let autoLoopRestore = null;
let autoLoopStopTxId = null;
let vitals={}, baseline={}, activeTx={}, decayTx={};
let treatmentLogEntries=[];
let appliedInjects=[], firedInject=new Set();
let triggeredOnce = new Set(); // remembers which injects already scheduled their triggers
let injectAutoOff = []; // [{txId, endT, injKey}]
const DEFAULT_BEEP_PATTERN = '1short';
const NO_BEEP_PATTERN = 'none';
const START_BEEP_FREQ = 1000;
const END_BEEP_FREQ = 650;
let lastActiveInjectKey = null;
let lastActiveInjectRef = null;
const DEFAULT_AUDIO_VOLUME = 100;
function normalizeAudioFootnote(a){
  if (!a || typeof a !== 'object') return '';
  const label = typeof a.footnoteLabel === 'string' ? a.footnoteLabel.trim() : '';
  const legacyValue = typeof a.footnoteLabelValue === 'string' ? a.footnoteLabelValue.trim() : '';
  let text = typeof a.footnoteText === 'string' ? a.footnoteText.trim() : '';
  if (!text){
    text = label || legacyValue;
  }
  if (text){
    a.footnoteText = text;
  } else {
    delete a.footnoteText;
  }
  if (Object.prototype.hasOwnProperty.call(a, 'footnoteLabel')){
    delete a.footnoteLabel;
  }
  if (Object.prototype.hasOwnProperty.call(a, 'footnoteLabelValue')){
    delete a.footnoteLabelValue;
  }
  return text;
}
function normalizeAudioVolume(value){
  const num = Number(value);
  if (!Number.isFinite(num)) return DEFAULT_AUDIO_VOLUME;
  const clamped = Math.min(100, Math.max(0, Math.round(num)));
  return clamped;
}
function applyAudioVolume(el, rec){
  if (!el) return DEFAULT_AUDIO_VOLUME;
  const vol = normalizeAudioVolume(rec && rec.volume);
  el.volume = Math.min(1, Math.max(0, vol / 100));
  return vol;
}

function setLoopButtonState(isOn){
  const btn = byId('p-audio-loop');
  if (btn){
    btn.textContent = isOn ? 'Loop: On' : 'Loop: Off';
    btn.classList.toggle('success', isOn);
  }
}

function clearAutoLoopTimer(restore){
  if (autoLoopTimer){
    clearTimeout(autoLoopTimer);
    autoLoopTimer = null;
  }
  autoLoopIndex = -1;
  autoLoopStopTxId = null;
  if (restore){
    const el = byId('p-audio');
    if (autoLoopRestore !== null){
      audioLoop = autoLoopRestore;
    }
    autoLoopRestore = null;
    if (el) el.loop = audioLoop;
    setLoopButtonState(audioLoop);
  }
}

function finishAutoLoop(index){
  if (autoLoopIndex !== index){
    clearAutoLoopTimer(false);
    return;
  }
  clearAutoLoopTimer(false);
  const el = byId('p-audio');
  const wasAutoIdx = (currentAudioIdx === index);
  if (el && wasAutoIdx){
    try{ el.pause(); }catch{}
    el.currentTime = 0;
  }
  if (wasAutoIdx){
    currentAudioIdx = -1;
  }
  updateAudioButtonStates();
  if (autoLoopRestore !== null){
    audioLoop = autoLoopRestore;
    autoLoopRestore = null;
  }
  if (el) el.loop = audioLoop;
  setLoopButtonState(audioLoop);
}

function maybeStartAutoLoop(){
  clearAutoLoopTimer(true);
  const el = byId('p-audio');
  if (!el) return;
  const list = Array.isArray(scenario.audios) ? scenario.audios : [];
  for (let i = 0; i < list.length; i += 1){
    const rec = list[i];
    if (!rec || !rec.loopOnStart) continue;
    const duration = Math.max(0, Math.floor(+rec.loopOnStartFor || 0));
    const stopTxId = (rec.loopStopOnTreatment || '').trim();
    const hasDuration = duration > 0;
    const src = getAudioSrc(rec);
    if (!src || (!hasDuration && !stopTxId)) continue;

    autoLoopRestore = audioLoop;
    audioLoop = true;
    setLoopButtonState(true);
    autoLoopIndex = i;
    autoLoopStopTxId = stopTxId || null;
    autoLoopTimer = hasDuration ? setTimeout(()=>finishAutoLoop(i), duration * 1000) : null;

    try{
      if (el.src !== src) el.src = src;
      el.loop = true;
      applyAudioVolume(el, rec);
      el.currentTime = 0;
      currentAudioIdx = i;
      updateAudioButtonStates();
      const playResult = el.play();
      if (playResult && typeof playResult.catch === 'function'){
        playResult.catch(err => {
          console.warn('Auto-start audio play failed:', err);
          alert('Browser blocked auto-playing audio. Click the audio button after interacting with the page.');
          if (currentAudioIdx === i){
            currentAudioIdx = -1;
            updateAudioButtonStates();
          }
          try{ el.pause(); }catch{}
          el.currentTime = 0;
          clearAutoLoopTimer(true);
        });
      }
    }catch(err){
      console.warn('Auto-start audio play failed:', err);
      alert('Browser blocked auto-playing audio. Click the audio button after interacting with the page.');
      if (currentAudioIdx === i){
        currentAudioIdx = -1;
        updateAudioButtonStates();
      }
      try{ el.pause(); }catch{}
      el.currentTime = 0;
      clearAutoLoopTimer(true);
    }
    return;
  }
}

function findTreatmentLabelById(id){
  if (!id) return '';
  const list = Array.isArray(scenario.treatments) ? scenario.treatments : [];
  const match = list.find(tx => tx && tx.id === id);
  return (match && (match.label || match.id)) || '';
}

function describeAudioAutoLoop(a){
  if (!a || !a.loopOnStart) return '';
  const parts = [];
  const seconds = Math.max(0, Math.floor(+a.loopOnStartFor || 0));
  if (seconds > 0){
    parts.push(`for ${fmt(seconds)}`);
  }
  const stopId = (a.loopStopOnTreatment || '').trim();
  if (stopId){
    const label = findTreatmentLabelById(stopId) || stopId;
    parts.push(`until ${label} is activated`);
  }
  if (!parts.length) return '';
  return `Loops on Start ${parts.join(' and ')}.`;
}

function maybeStopAutoLoopForTreatment(txId){
  if (!txId) return;
  if (!autoLoopStopTxId || autoLoopStopTxId !== txId) return;
  const index = autoLoopIndex;
  if (index >= 0){
    finishAutoLoop(index);
  } else {
    clearAutoLoopTimer(true);
  }
}

function ensureTxState(id){
  activeTx[id] = activeTx[id] || { on:false, done:false };
  return activeTx[id];
}

function recordTreatmentStart(id, label){
  const entry = {
    id,
    label,
    startedAt: Math.max(0, elapsed|0),
    startedRemaining: Math.max(0, tLeft|0),
    endedAt: null
  };
  treatmentLogEntries.push(entry);
}

function recordTreatmentStop(id){
  for (let i = treatmentLogEntries.length - 1; i >= 0; i--){
    const entry = treatmentLogEntries[i];
    if (entry.id === id && entry.endedAt == null){
      entry.endedAt = Math.max(0, elapsed|0);
      break;
    }
  }
}

function setTreatmentOn(id, label){
  const state = ensureTxState(id);
  const wasOn = !!state.on;
  state.on = true;
  state.done = false;
  if (!wasOn){
    recordTreatmentStart(id, label);
    maybeStopAutoLoopForTreatment(id);
  }
  return !wasOn;
}

function setTreatmentOff(id){
  const state = ensureTxState(id);
  const wasOn = !!state.on;
  state.on = false;
  if (wasOn){
    recordTreatmentStop(id);
  }
  return wasOn;
}

function ensureInjectBeepDefaultsFor(inj){
  if (!inj) return inj;
  if (!inj.beepPattern) inj.beepPattern = DEFAULT_BEEP_PATTERN;
  if (!inj.endBeepPattern) inj.endBeepPattern = inj.beepPattern || DEFAULT_BEEP_PATTERN;
  if (inj.txAutoOff === undefined) inj.txAutoOff = true;
  return inj;
}
function ensureInjectListDefaults(list){
  if (!Array.isArray(list)) return [];
  list.forEach(ensureInjectBeepDefaultsFor);
  return list;
}

function toneOnce(freq=1000, ms=200, vol=0.25){
  runToneWithContext(ctx=>{
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.connect(g);
    g.connect(ctx.destination);
    o.type = 'square';
    o.frequency.value = freq;
    g.gain.value = vol;
    o.start();
    setTimeout(()=>{
      try{o.stop();}catch{}
      try{o.disconnect();}catch{}
      try{g.disconnect();}catch{}
    }, ms);
  });
}

function playBeepPattern(pattern, freq = START_BEEP_FREQ){
  if (!pattern || pattern === NO_BEEP_PATTERN) return;
  const seq = (()=>{
    if (pattern === '1short') return [200];
    if (pattern === '2short') return [200,150,200];
    if (pattern === '3short') return [200,150,200,150,200];
    return [700];
  })();
  let t = 0;
  for (let i = 0; i < seq.length; i++){
    const isGap = i % 2 === 1;
    if (isGap){ t += seq[i]; continue; }
    const dur = seq[i];
    setTimeout(()=>toneOnce(freq, dur, 0.25), t);
    t += dur;
    if (i < seq.length - 1) t += (seq[i+1] || 0);
  }
}

function playInjectStartBeep(inj){
  const pat = ensureInjectBeepDefaultsFor(inj)?.beepPattern || DEFAULT_BEEP_PATTERN;
  playBeepPattern(pat, START_BEEP_FREQ);
}

function playInjectEndBeep(inj){
  const pat = ensureInjectBeepDefaultsFor(inj)?.endBeepPattern || DEFAULT_BEEP_PATTERN;
  playBeepPattern(pat, END_BEEP_FREQ);
}

// Loud single beep used at inject fire
function blast(f=1000,m=700){
  try{
    const C=new (window.AudioContext||window.webkitAudioContext)();
    const o=C.createOscillator(), g=C.createGain();
    o.connect(g); g.connect(C.destination);
    o.type="square"; o.frequency.value=f; g.gain.value=.25;
    o.start(); setTimeout(()=>{o.stop(); C.close()}, m);
  }catch{}
}
function openUrgent(msg){
  const m = byId('urgent-modal');
  const t = byId('urgent-message');
  if(!m||!t) return;
  t.textContent = (msg && String(msg).trim()) || 'Treatment activated.';
  m.classList.add('show');
  m.setAttribute('aria-hidden','false');
}
function closeUrgent(){
  const m = byId('urgent-modal');
  if(!m) return;
  m.classList.remove('show');
  m.setAttribute('aria-hidden','true');
}

// Parse "id:delay,id2:delay" where delay can be "90" or "1:30"
function parseTriggers(str){
  if(!str) return [];
  return String(str).split(',').map(s=>s.trim()).filter(Boolean).map(s=>{
    const idx=s.lastIndexOf(':');
    const id = idx>=0 ? s.slice(0,idx).trim() : s.trim();
    const raw = idx>=0 ? s.slice(idx+1).trim() : "0";
    const d = parseTimeFlexible(raw);
    return {id, delay: d>=0 ? d : 0};
  });
}
function injKey(inj){ return (inj.id||inj.name||'inj')+'@'+inj.t; }

function scheduleTriggersOnce(inj, now){
  const key = injKey(inj);
  if (triggeredOnce.has(key)) return;
  triggeredOnce.add(key);
  
  // 1) explicit triggers (id:delay) win
  if (Array.isArray(inj.triggers) && inj.triggers.length){
    inj.triggers.forEach(tr=>{
      const base=(scenario.injects||[]).find(x=>x.id===tr.id);
      if (base){
        ensureInjectBeepDefaultsFor(base);
        // remove future duplicates of the same id so chain takes over
        appliedInjects = appliedInjects.filter(x => !(x.id===base.id && x.t>now));
        appliedInjects.push({...base, t: now + (+tr.delay||0)});
      }
    });
    appliedInjects.sort((a,b)=>a.t-b.t);   // <-- add here
    return;
  }

  // 2) fallback: next inject by editor order, preserve original gap
  const order = (scenario.injects||[]).map(j=>j.id);
  const i = order.indexOf(inj.id);
  if (i>=0 && i<order.length-1){
    const nextBase = (scenario.injects||[])[i+1];
    if (nextBase){
      ensureInjectBeepDefaultsFor(nextBase);
      appliedInjects = appliedInjects.filter(x => !(x.id===nextBase.id && x.t>now));
      const nextGap = Math.max(0, ((+nextBase.t)||0) - ((+inj.t)||0));
      appliedInjects.push({
        ...nextBase,
        t: now + nextGap
      });
      appliedInjects.sort((a,b)=>a.t-b.t);        // <-- and add here
    }
  }
}
function activateTxFromInject(inj, now){
  if (!inj || !Array.isArray(inj.txOn) || !inj.txOn.length) return;
  const endT = now + Math.max(0, +inj.dur || 0);
  const key = injKey(inj);

  inj.txOn.forEach(id => {
    if (!id) return;
    const txDef = (scenario.treatments||[]).find(t=>t.id===id);
    const label = (txDef && txDef.label) ? txDef.label : id;
    setTreatmentOn(id, label);
    if (txDef && txDef.urgent){
      openUrgent(txDef.urgentMsg || (txDef.label || 'Treatment') + ' activated.');
    }
    // remember to turn off when inject ends (only if it has a duration)
    if ((+inj.dur||0) > 0 && inj.txAutoOff !== false){
      injectAutoOff.push({ txId:id, endT, injKey:key });
    }
  });
  renderAll();
}
function applyInjectAutoOff(now){
  // turn off and start decay at inject end
  injectAutoOff = injectAutoOff.filter(rec => {
    if (now >= rec.endT){
      if (setTreatmentOff(rec.txId)){
        decayTx[rec.txId] = true; // let vitals drift back
      }
      return false; // drop this record
    }
    return true;
  });
}

function startNextInject(fromId){
  const order = (scenario.injects||[]).map(j=>j.id);
  const i = order.indexOf(fromId);
  if (i >= 0 && i < order.length - 1){
    const nextBase = (scenario.injects||[])[i+1];
    if (nextBase){
      ensureInjectBeepDefaultsFor(nextBase);
      // remove future duplicates of the same id so manual chain takes over
      appliedInjects = appliedInjects.filter(x => !(x.id === nextBase.id && x.t > elapsed));
      appliedInjects.push({...nextBase, t: elapsed}); // start countdown now
      appliedInjects.sort((a,b)=>a.t-b.t);
      renderInjects();
      log(`Manually started next inject: ${nextBase.name||nextBase.id}`);
    }
  }
}

/* ---------------- Engine ---------------- */
function resetRun(){
  running=false; if(interval){ clearInterval(interval); interval=null; }
  tLeft=(scenario.timing.minutes||15)*60; elapsed=0;
  vitals={...scenario.vitals}; baseline={...scenario.vitals};
  activeTx={}; decayTx={};
  treatmentLogEntries=[];
  ensureInjectListDefaults(scenario.injects);
  appliedInjects=[...(scenario.injects||[])].sort((a,b)=>a.t-b.t);
  firedInject.clear();
  triggeredOnce.clear();
  injectAutoOff = [];
  lastActiveInjectKey = null;
  lastActiveInjectRef = null;

  // reset audio playback state
  clearAutoLoopTimer(true);
  const audioEl = byId('p-audio');
  if (audioEl){
    try{ audioEl.pause(); }catch{}
    audioEl.currentTime = 0;
    audioEl.loop = false;
  }
  currentAudioIdx = -1;
  audioLoop = false;
  setLoopButtonState(false);

  closeUrgent();
  buildTxButtons();
  renderAll();
  if (typeof updateAudioButtonStates === 'function') updateAudioButtonStates();
}
function start(){ if (running) return; running=true; maybeStartAutoLoop(); interval=setInterval(tick,1000); }
function pause(){ running=false; if(interval){ clearInterval(interval); interval=null; } }
function tick(){
  if (tLeft<=0){ pause(); endBell(); return; }
  tLeft -= 1; elapsed += 1;
  // countdown warning at ≤ 2:00
  const playBadge = byId('p-timer');                 // this span IS the badge on PLAY
  const buildBadge = byId('timer')?.parentElement;   // timer's enclosing badge on BUILD
  const warn = tLeft <= 120;
  if (playBadge)  playBadge.classList.toggle('flash-warn', warn);
  if (buildBadge) buildBadge.classList.toggle('flash-warn', warn);
  applyEffectsPerSecond();
  applyInjectAutoOff(elapsed);
  renderAll();
}
function endBell(){ tone(660,400); setTimeout(()=>tone(880,400),450); setTimeout(()=>tone(660,400),900); }

function enforceCaps(){
  const keys=['hr','rr','spo2','sbp','dbp','cbg'];
  const up={}, down={}, minFloor={};
  for (const tx of scenario.treatments){
    const st=activeTx[tx.id]; if(!st||!st.on) continue;
    const eff=tx.eff||{}, cap=tx.cap||{}, min=tx.min||{};
    for (const k of keys){
      const d=+eff[k]||0;
      if (cap[k]!=null){
        if (d>0) up[k]=up[k]==null?cap[k]:Math.min(up[k],cap[k]);
        if (d<0) down[k]=down[k]==null?cap[k]:Math.max(down[k],cap[k]);
      }
      if (min[k]!=null){
        minFloor[k]=minFloor[k]==null?min[k]:Math.max(minFloor[k],min[k]);
      }
    }
  }
  Object.keys(up).forEach(k=>{ vitals[k]=Math.min(vitals[k], up[k]); });
  Object.keys(down).forEach(k=>{ vitals[k]=Math.max(vitals[k], down[k]); });
  Object.keys(minFloor).forEach(k=>{ vitals[k]=Math.max(vitals[k], minFloor[k]); });
}

function applyEffectsPerSecond(){
  const vitKeys = ['hr','rr','spo2','sbp','dbp','cbg'];

  const getBase = (k) => {
    const b = (baseline && typeof baseline[k] === 'number') ? baseline[k] : Number(scenario.vitals?.[k] ?? 0);
    return Number.isFinite(b) ? b : 0;
  };

  for (const k of vitKeys){
    if (vitals[k] == null) vitals[k] = getBase(k);
  }

  const activeList = (scenario.treatments || [])
    .filter(tx => activeTx[tx.id]?.on)
    .sort((a,b) => (b.priority||0) - (a.priority||0));

  const delta  = Object.fromEntries(vitKeys.map(k => [k, 0]));
  const minCap = Object.fromEntries(vitKeys.map(k => [k, null]));
  const maxCap = Object.fromEntries(vitKeys.map(k => [k, null]));

  for (const tx of activeList){
    const eff = tx.eff || {};
    const mn  = tx.min || {};
    const cp  = tx.cap || {};
    for (const k of vitKeys){
      if (delta[k] === 0){
        const d = Number(eff[k] || 0);
        if (d) delta[k] = d;
      }
      if (minCap[k] == null && mn[k] != null && mn[k] !== '') minCap[k] = Number(mn[k]);
      if (maxCap[k] == null && cp[k] != null && cp[k] !== '') maxCap[k] = Number(cp[k]);
    }
  }

  for (const k of vitKeys){
    let v = Number(vitals[k]);

    if (delta[k] !== 0){
      v += delta[k];
    } else {
      const base = getBase(k);
      const diff = base - v;
      if (Math.abs(diff) >= 0.5){
        v += Math.sign(diff) * 0.5;
      } else {
        v = base;
      }
    }

    if (minCap[k] != null && v < minCap[k]) v = minCap[k];
    if (maxCap[k] != null && v > maxCap[k]) v = maxCap[k];

    if (k === 'spo2'){ if (v < 0) v = 0; if (v > 100) v = 100; }
    if (k === 'hr')  { if (v < 0) v = 0; if (v > 240) v = 240; }
    if (k === 'rr')  { if (v < 0) v = 0; if (v > 60)  v = 60;  }
    if (k === 'sbp') { if (v < 0) v = 0; if (v > 260) v = 260; }
    if (k === 'dbp') { if (v < 0) v = 0; if (v > 160) v = 160; }
    if (k === 'cbg') { if (v < 0) v = 0; if (v > 600) v = 600; }

    vitals[k] = v;
  }
}

/* ---------------- Render ---------------- */
function renderInjects(){
  const host = byId('inject-counts'); if (!host) return; host.innerHTML = '';
  const now = elapsed;

  ensureInjectListDefaults(appliedInjects);
  const prevActiveKey = lastActiveInjectKey;
  const prevActive = lastActiveInjectRef;

  // keep list sorted
  appliedInjects = [...appliedInjects].sort((a,b)=>a.t-b.t);

  // fire zero-duration injects once when their time is reached
  for (const inj of appliedInjects){
    const dur = +inj.dur || 0;
    const fireT = (+inj.t) | 0;
    if (dur === 0 && now >= fireT && !firedInject.has(injKey(inj))){
      firedInject.add(injKey(inj));
      playInjectStartBeep(inj);
      scheduleTriggersOnce(inj, now);
      activateTxFromInject(inj, now);
    }
  }

  // find current active inject (has duration and is within its window)
  let active = null;
  for (const inj of appliedInjects){
    const dur = +inj.dur || 0; if (!dur) continue;
    const fireT = (+inj.t) | 0, endT = fireT + dur;
    if (now >= fireT && now <= endT){
      if (!active || fireT > ((+active?.t) | 0)) active = inj;
    }
  }

  // render active pill (flash red, countdown, beep + chain once)
  if (active){
    const key = injKey(active);
    if (prevActive && prevActiveKey !== key){
      playInjectEndBeep(prevActive);
    }
    if (!firedInject.has(key)){
      firedInject.add(key);
      playInjectStartBeep(active);
      scheduleTriggersOnce(active, now);
      activateTxFromInject(active, now);
    }
    const left = (active.t + (+active.dur || 0)) - now;
    const pill = document.createElement('span');
    pill.className = 'pill inject-big active pflash';
    pill.style.setProperty('--pulse-color','#fee2e2');
    if (active.bg) pill.style.background = active.bg;
    pill.textContent = `${active.name} ${fmt(Math.max(0,left))}`;
    host.appendChild(pill);
    lastActiveInjectKey = key;
    lastActiveInjectRef = active;
    return;
  }

  if (prevActive){
    playInjectEndBeep(prevActive);
  }
  lastActiveInjectKey = null;
  lastActiveInjectRef = null;

  // otherwise show the single next upcoming inject
  const next = appliedInjects.find(inj => inj.t > now);
  if (next){
    const remain = next.t - now;
    const pill = document.createElement('span');
    pill.className = 'pill inject-big';
    if (next.bg) pill.style.background = next.bg;
    pill.textContent = `Next: ${next.name} in ${fmt(remain)}`;
    host.appendChild(pill);
  }
} // <-- CRITICAL: close the function

function beep(count=1){
  const seq=[880,880,880].slice(0,count);
  let t=0;
  seq.forEach(f=>{ setTimeout(()=>tone(f,220), t); t+=350; });
}

function renderStatic(){
  const set = (id, val) => { const el = byId(id); if (el) el.textContent = val; };
  set('timer', fmt(tLeft)); set('p-timer', fmt(tLeft));
  set('p-hr', Math.round(vitals.hr)); set('p-rr', Math.round(vitals.rr));
  set('p-spo2', vitals.spo2.toFixed(1)); set('p-bp', Math.round(vitals.sbp) + "/" + Math.round(vitals.dbp));
  set('p-cbg', Math.round(vitals.cbg));

  // derive descriptors and skin from baseline + any active tx.set
  const descKeys = ['hrRate','hrRhythm','hrQuality','rrRate','rrRhythm','rrQuality','skinColor','skinTemp','skinMoist'];
  const desc = {};
  descKeys.forEach(k => { desc[k] = baseline[k]; });
  for (const tx of (scenario.treatments || [])){
    const st = activeTx[tx.id]; if (!st || !st.on) continue;
    const txSet = tx.set || {};
    for (const k of descKeys){ if (txSet[k] != null) desc[k] = txSet[k]; }
  }

  const hrDesc = `Rate: ${desc.hrRate||'normal'} | Rhythm: ${desc.hrRhythm||'regular'} | Quality: ${desc.hrQuality||'normal'}`;
  const rrDesc = `Rate: ${desc.rrRate||'normal'} | Rhythm: ${desc.rrRhythm||'regular'} | Quality: ${desc.rrQuality||'normal'}`;

  // show HR/RR descriptors
  set('p-hr-desc', hrDesc);
  set('p-rr-desc', rrDesc);

  // SAMPLE block
  if (byId('p-sample')){
    const s = scenario.sample;
    byId('p-sample').innerHTML =
      `<div><strong>S:</strong> ${s.s||''}</div>
       <div><strong>A:</strong> ${s.a||''}</div>
       <div><strong>M:</strong> ${s.m||''}</div>
       <div><strong>P:</strong> ${s.p||''}</div>
       <div><strong>L:</strong> ${s.l||''}</div>
       <div><strong>E:</strong> ${s.e||''}</div>`;
  }

  // OPQRST block
  if (byId('p-opqrst')){
    const o=scenario.opqrst||{};
    byId('p-opqrst').innerHTML =
      `<div><strong>O:</strong> ${o.o||''}</div>
       <div><strong>P:</strong> ${o.p||''}</div>
       <div><strong>Q:</strong> ${o.q||''}</div>
       <div><strong>R:</strong> ${o.r||''}</div>
       <div><strong>S:</strong> ${o.s||''}</div>
       <div><strong>T:</strong> ${o.t||''}</div>`;
  }

  // Physical bullets
  const physEl = byId('p-physical');
  if (physEl){
    const raw = scenario.sample.phys || '';
    const items = raw.split(/\n+|[.;]\s+/).map(s=>s.trim()).filter(Boolean);
    physEl.innerHTML = items.length ? `<ul>${items.map(x=>`<li>${x}</li>`).join('')}</ul>` : '—';
  }

  // Dispatch, GI, AVPU/NOI/C-spine
  const pd=byId('p-dispatch'), pg=byId('p-gi'), pa=byId('p-ancillary');
  if (pd) pd.textContent=scenario.text.dispatch||'';
  if (pg) pg.textContent=scenario.text.gi||'';
  if (pa) pa.innerHTML = `<div><strong>AVPU:</strong> ${scenario.text.avpu||''}</div>
    <div><strong>NOI/MOI:</strong> ${scenario.text.noi||''}</div>
    <div><strong>C-spine:</strong> ${scenario.text.cspine||''}</div>`;

  // Skin triplet
  const skinEl=byId('p-skin');
  if (skinEl){
    skinEl.textContent = `${desc.skinColor||'--'} / ${desc.skinTemp||'--'} / ${desc.skinMoist||'--'}`;
  }

  // ALS badges and checkboxes
  const alsA=byId('als-badge'), alsP=byId('p-als-badge');
  if (alsA) alsA.classList.toggle('hidden', !scenario.flags.als);
  if (alsP) alsP.classList.toggle('hidden', !scenario.flags.als);
  const cb=byId('flag-als-build'), cp=byId('flag-als-play');
  if (cb) cb.checked=!!scenario.flags.als;
  if (cp) cp.checked=!!scenario.flags.als;

  const playFlags = scenario.displayOnPlay || {};
  const show = (id, flag)=>{ const el=byId(id); if(el) el.classList.toggle('hidden', !flag); };
  show('play-text-section', playFlags.text !== false);
  show('p-sample-wrap', playFlags.sample !== false);
  show('p-opqrst-wrap', playFlags.opqrst !== false);
  const physBlock = byId('p-physical');
  if (physBlock){
    const hidePhys = playFlags.physical === false;
    physBlock.classList.toggle('hidden', hidePhys);
    const heading = physBlock.previousElementSibling;
    if (heading && heading.tagName==='H3') heading.classList.toggle('hidden', hidePhys);
  }

  renderTreatmentLog();

  // Always refresh audio button list, then sync playing state
  if (typeof renderAudioButtons === 'function') renderAudioButtons();
  if (typeof updateAudioButtonStates === 'function') updateAudioButtonStates();
}

function renderTreatmentLog(){
  const host = byId('p-treatment-log');
  if (!host) return;

  host.innerHTML = '';

  if (!treatmentLogEntries.length){
    const empty = document.createElement('div');
    empty.className = 'tx-log-empty';
    empty.textContent = 'No treatments started yet.';
    host.appendChild(empty);
    return;
  }

  const header = document.createElement('div');
  header.className = 'tx-log-header';

  const nameHead = document.createElement('div');
  nameHead.textContent = 'Treatment';
  const startHead = document.createElement('div');
  startHead.textContent = 'Activated';
  const timerHead = document.createElement('div');
  timerHead.textContent = 'Timer';

  header.append(nameHead, startHead, timerHead);
  host.appendChild(header);

  const now = Math.max(0, elapsed|0);

  treatmentLogEntries.forEach(entry => {
    const row = document.createElement('div');
    row.className = 'tx-log-entry';
    if (entry.endedAt == null){
      row.classList.add('tx-log-entry--active');
    }

    const labelEl = document.createElement('div');
    labelEl.className = 'tx-log-label';
    labelEl.textContent = entry.label;

    const startEl = document.createElement('div');
    startEl.className = 'tx-log-start';
    startEl.textContent = `T+${fmt(entry.startedAt)}`;
    if (typeof entry.startedRemaining === 'number'){
      startEl.title = `${fmt(entry.startedRemaining)} remaining when started`;
    }

    const elapsedEl = document.createElement('div');
    elapsedEl.className = 'tx-log-elapsed';
    const endPoint = entry.endedAt == null ? now : entry.endedAt;
    const diff = Math.max(0, endPoint - entry.startedAt);
    elapsedEl.textContent = fmt(diff);

    row.append(labelEl, startEl, elapsedEl);
    host.appendChild(row);
  });
}


function renderAll(){ renderStatic(); renderInjects(); }

/* ---------------- UI builders ---------------- */
function buildTxButtons(){
  function mount(id){
    const host = byId(id);
    if (!host) return;
    host.innerHTML = '';

    (scenario.treatments || []).forEach(tx => {
      const b = document.createElement('button');
      b.className = 'btn';
      b.textContent = tx.label || tx.id;

      const getOn  = () => (tx.bgOn || tx.bg || '');
      const getOff = () => (tx.bg   || '');

      // vars for flash animation
      b.style.setProperty('--on',  getOn());
      b.style.setProperty('--off', getOff());

      // initial state
      const isOnInit = !!(activeTx[tx.id] && activeTx[tx.id].on);
      b.classList.toggle('success', isOnInit);
      b.classList.toggle('tx-on',   isOnInit);
      if (isOnInit && tx.flashOn){
        b.classList.add('tflash');
        b.style.background = '';               // animation controls bg
      } else {
        b.classList.remove('tflash');
        b.style.background = isOnInit ? getOn() : getOff();
      }

      // click -> toggle state + visuals
      b.addEventListener('click', () => {
        const label = tx.label || tx.id;
        if (tx.mode === 'toggle'){
          if (activeTx[tx.id]?.on){
            if (setTreatmentOff(tx.id)){
              decayTx[tx.id] = true;
            }
          } else {
            setTreatmentOn(tx.id, label);
          }
        } else {
          setTreatmentOn(tx.id, label);
        }

        // refresh vars in case colors changed
        b.style.setProperty('--on',  getOn());
        b.style.setProperty('--off', getOff());

        const isOn = !!(activeTx[tx.id] && activeTx[tx.id].on);
        b.classList.toggle('success', isOn);
        b.classList.toggle('tx-on',   isOn);

        if (isOn && tx.flashOn){
          b.classList.add('tflash');
          b.style.background = '';
        } else {
          b.classList.remove('tflash');        // stop flashing when OFF
          b.style.background = isOn ? getOn() : getOff();
        }
        // URGENT popup on activation
        if (isOn && tx.urgent){
          openUrgent(tx.urgentMsg || (tx.label || 'Treatment') + ' activated.');
        }
        renderAll();
      });

      host.appendChild(b);
    });
  }

  mount('tx-buttons');
  mount('p-tx-buttons');
}


function drawTreatments(){
  const host=byId('tx-list'); if(!host) return; host.innerHTML='';
  (scenario.treatments||[]).forEach((tx,i)=>{
    const box=document.createElement('div');
    box.className='kv';
    if (tx._collapsed) box.classList.add('collapsed');

    box.innerHTML=`
      <div class="row hdr">
        <button class="icon-btn tgl" type="button" aria-label="Toggle details" aria-expanded="${!tx._collapsed ? 'true' : 'false'}">${tx._collapsed ? '►' : '▼'}</button>
        <label style="flex:2">Label <input class="label" value="${tx.label||''}"></label>
        <label style="flex:1">ID <input class="id" value="${tx.id||''}"></label>
        <label style="flex:1">Mode <select class="mode">
          <option value="toggle" ${tx.mode==='toggle'?'selected':''}>toggle</option>
          <option value="oneShot" ${tx.mode==='oneShot'?'selected':''}>oneShot</option></select></label>
        <label style="flex:0" title="Background color when OFF">
            BG <input class="bg" type="color" value="${tx.bg || '#fafafa'}"
                style="width:46px;padding:0;border:0;background:transparent">
        </label>
        <label style="flex:0" title="Background color when ON">
            BG On <input class="bg-on" type="color" value="${tx.bgOn || tx.bg || '#c7f7c7'}"
               style="width:60px;padding:0;border:0;background:transparent">
        </label>
        <label style="flex:0" title="Flash between BG On and BG while ON">
          Flash <input class="flash-on" type="checkbox" ${tx.flashOn ? 'checked' : ''}>
        </label>
        <label style="width:90px" title="Higher runs first">
            Priority <input class="prio" type="number" value="${tx.priority??0}">
        </label>
        <label style="width:110px" title="If set, this treatment’s per-vital deltas override lower priority deltas">
            Override <input class="ovr" type="checkbox" ${tx.override?'checked':''}>
        </label>

        <button class="btn danger del" type="button">Delete</button>
      </div>

      <div class="body">
 <div class="vital-rows">
  <div class="vital-row head">
    <div></div><div>Δ per second</div><div>Target</div><div>Max (cap)</div><div>Min (floor)</div>
  </div>

  <div class="vital-row">
    <div class="vlabel">HR</div>
    <input class="e-hr"  type="number" step="0.01" value="${tx.eff?.hr||0}">
    <input class="t-hr"  type="number" step="0.1"  value="">
    <input class="c-hr"  type="number" step="0.1"  value="${tx.cap?.hr??''}"  placeholder="none">
    <input class="m-hr"  type="number" step="0.1"  value="${tx.min?.hr??''}"  placeholder="none">
  </div>

  <div class="vital-row">
    <div class="vlabel">RR</div>
    <input class="e-rr"  type="number" step="0.01" value="${tx.eff?.rr||0}">
    <input class="t-rr"  type="number" step="0.1"  value="">
    <input class="c-rr"  type="number" step="0.1"  value="${tx.cap?.rr??''}"  placeholder="none">
    <input class="m-rr"  type="number" step="0.1"  value="${tx.min?.rr??''}"  placeholder="none">
  </div>

  <div class="vital-row">
    <div class="vlabel">SpO₂</div>
    <input class="e-spo2"  type="number" step="0.01" value="${tx.eff?.spo2||0}">
    <input class="t-spo2"  type="number" step="0.1"  value="">
    <input class="c-spo2"  type="number" step="0.1"  value="${tx.cap?.spo2??''}"  placeholder="none">
    <input class="m-spo2"  type="number" step="0.1"  value="${tx.min?.spo2??''}"  placeholder="none">
  </div>

  <div class="vital-row">
    <div class="vlabel">SBP</div>
    <input class="e-sbp"  type="number" step="0.01" value="${tx.eff?.sbp||0}">
    <input class="t-sbp"  type="number" step="0.1"  value="">
    <input class="c-sbp"  type="number" step="0.1"  value="${tx.cap?.sbp??''}"  placeholder="none">
    <input class="m-sbp"  type="number" step="0.1"  value="${tx.min?.sbp??''}"  placeholder="none">
  </div>

  <div class="vital-row">
    <div class="vlabel">DBP</div>
    <input class="e-dbp"  type="number" step="0.01" value="${tx.eff?.dbp||0}">
    <input class="t-dbp"  type="number" step="0.1"  value="">
    <input class="c-dbp"  type="number" step="0.1"  value="${tx.cap?.dbp??''}"  placeholder="none">
    <input class="m-dbp"  type="number" step="0.1"  value="${tx.min?.dbp??''}"  placeholder="none">
  </div>

  <div class="vital-row">
    <div class="vlabel">CBG</div>
    <input class="e-cbg"  type="number" step="0.01" value="${tx.eff?.cbg||0}">
    <input class="t-cbg"  type="number" step="0.1"  value="">
    <input class="c-cbg"  type="number" step="0.1"  value="${tx.cap?.cbg??''}"  placeholder="none">
    <input class="m-cbg"  type="number" step="0.1"  value="${tx.min?.cbg??''}"  placeholder="none">
  </div>
</div>
<div class="vital-help">
  Tip: <strong>Target</strong> pins a vital by setting Min = Max = Target. Leave Min/Max blank for “no limit”.
</div>

        <div class="divider"></div>

<div class="inline-line">
  <span class="group-h">Pulse</span>
  <label>Rate
    <select class="set-hr-rate">
      <option value="">(no change)</option>
      <option value="normal">normal</option>
      <option value="tachycardic">tachycardic</option>
      <option value="bradycardic">bradycardic</option>
      <option value="absent">absent</option>
    </select>
  </label>
  <label>Rhythm
    <select class="set-hr-rhythm">
      <option value="">(no change)</option>
      <option value="regular">regular</option>
      <option value="irregular">irregular</option>
      <option value="absent">absent</option>
    </select>
  </label>
  <label>Quality
    <select class="set-hr-quality">
      <option value="">(no change)</option>
      <option value="normal">normal</option>
      <option value="weak">weak</option>
      <option value="thready">thready</option>
      <option value="bounding">bounding</option>
      <option value="absent">absent</option>
    </select>
  </label>
</div>

<div class="inline-line">
  <span class="group-h">Resp</span>
  <label>Rate
    <select class="set-rr-rate">
      <option value="">(no change)</option>
      <option value="normal">normal</option>
      <option value="tachypneic">tachypneic</option>
      <option value="bradypneic">bradypneic</option>
      <option value="absent">absent</option>
    </select>
  </label>
  <label>Rhythm
    <select class="set-rr-rhythm">
      <option value="">(no change)</option>
      <option value="regular">regular</option>
      <option value="irregular">irregular</option>
      <option value="absent">absent</option>
    </select>
  </label>
  <label>Quality
    <select class="set-rr-quality">
      <option value="">(no change)</option>
      <option value="normal">normal</option>
      <option value="shallow">shallow</option>
      <option value="labored">labored</option>
      <option value="absent">absent</option>
    </select>
  </label>
</div>

<div class="inline-line">
  <span class="group-h">Skin</span>
  <label>Color
    <select class="set-skin-color">
      <option value="">(no change)</option>
      <option value="normal">normal</option>
      <option value="pink">pink</option>
      <option value="pale">pale</option>
      <option value="flushed">flushed</option>
      <option value="cyanotic">cyanotic</option>
      <option value="mottled">mottled</option>
      <option value="jaundiced">jaundiced</option>
    </select>
  </label>
  <label>Temp
    <select class="set-skin-temp">
      <option value="">(no change)</option>
      <option value="warm">warm</option>
      <option value="hot">hot</option>
      <option value="cool">cool</option>
      <option value="cold">cold</option>
    </select>
  </label>
  <label>Moisture
    <select class="set-skin-moist">
      <option value="">(no change)</option>
      <option value="dry">dry</option>
      <option value="normal">normal</option>
      <option value="moist">moist</option>
      <option value="clammy">clammy</option>
      <option value="diaphoretic">diaphoretic</option>
    </select>
  </label>
</div>
<div class="divider"></div>
<div class="row" style="align-items:center">
  <label class="switch" title="Show an URGENT popup when this treatment is activated">
    <input class="urgent" type="checkbox">
    <span>Show URGENT popup when activated</span>
  </label>
</div>
<label>Urgent message
  <textarea class="urgent-msg" rows="2" placeholder="Message shown in the red URGENT popup"></textarea>
</label>
</div>`;

    const q=s=>box.querySelector(s);

    // arrow toggle
    const tgl=box.querySelector('.tgl');
    if (tgl){
      tgl.addEventListener('click', ()=>{
        const collapsed = box.classList.toggle('collapsed');
        tgl.textContent = collapsed ? '►' : '▼';
        tgl.setAttribute('aria-expanded', String(!collapsed));
        tx._collapsed = collapsed; // persist in scenario
        save(); // re-render with state saved
      });
      
    }

    // field handlers
q('.label').onchange=()=>{ tx.label=q('.label').value; save(); };
q('.id').onchange=()=>{ tx.id=q('.id').value; save(); };
q('.mode').onchange=()=>{ tx.mode=q('.mode').value; save(); };

const bgEl = q('.bg'); if (bgEl) bgEl.onchange = () => { tx.bg = bgEl.value; save(); };
const flashEl = q('.flash-on');
if (flashEl) flashEl.onchange = () => { tx.flashOn = !!flashEl.checked; save(); };
const bgOnEl = q('.bg-on'); if (bgOnEl) bgOnEl.onchange = () => { tx.bgOn = bgOnEl.value; save(); };

// URGENT controls
const urgEl = q('.urgent');
if (urgEl){ urgEl.checked = !!tx.urgent; urgEl.onchange = ()=>{ tx.urgent = !!urgEl.checked; save(); }; }

const urgMsgEl = q('.urgent-msg');
if (urgMsgEl){
  urgMsgEl.value = tx.urgentMsg || '';
  urgMsgEl.oninput = ()=>{
    tx.urgentMsg = urgMsgEl.value;
    save({skipRedraw:true});
  };
}

// Δ per second + Max
['hr','rr','spo2','sbp','dbp','cbg'].forEach(k=>{
  q('.e-'+k).onchange=()=>{ tx.eff=tx.eff||{}; tx.eff[k]=parseFloat(q('.e-'+k).value||0); save(); };
  q('.c-'+k).onchange=()=>{ tx.cap=tx.cap||{}; const v=q('.c-'+k).value; tx.cap[k]=v===''?null:parseFloat(v); save(); };
});

// Min
['hr','rr','spo2','sbp','dbp','cbg'].forEach(k=>{
  const el=q('.m-'+k);
  if(el) el.onchange=()=>{ tx.min=tx.min||{}; const v=el.value; tx.min[k]=v===''?null:parseFloat(v); save(); };
});

// >>> ADD TARGET HANDLERS HERE <<<
['hr','rr','spo2','sbp','dbp','cbg'].forEach(k=>{
  const tel = q('.t-'+k);              // the Target input in your new row
  if (!tel) return;
  tel.onchange = ()=>{
    const raw = tel.value;
    if (raw === '' || raw == null) return;   // clearing target does nothing
    const num = parseFloat(raw);
    tx.min = tx.min || {};
    tx.cap = tx.cap || {};
    tx.min[k] = num;                          // pin to target
    tx.cap[k] = num;

    // reflect into visible Min/Max fields immediately
    const minEl = q('.m-'+k), capEl = q('.c-'+k);
    if (minEl) minEl.value = String(num);
    if (capEl) capEl.value = String(num);
    save();
  };
});

const setSel=(cls,key)=>{ const el=q(cls); if(!el) return; el.value=tx.set?.[key]??''; el.onchange=()=>{ tx.set=tx.set||{}; tx.set[key]=el.value===''?null:el.value; save(); }; };
setSel('.set-hr-rate','hrRate'); setSel('.set-hr-rhythm','hrRhythm'); setSel('.set-hr-quality','hrQuality');
setSel('.set-rr-rate','rrRate'); setSel('.set-rr-rhythm','rrRhythm'); setSel('.set-rr-quality','rrQuality');
setSel('.set-skin-color','skinColor'); setSel('.set-skin-temp','skinTemp'); setSel('.set-skin-moist','skinMoist');

const prEl=q('.prio'); if (prEl) prEl.onchange=()=>{ tx.priority=parseInt(prEl.value||'0',10); save(); };
const ovEl=q('.ovr');  if (ovEl)  ovEl.onchange = ()=>{ tx.override=!!ovEl.checked; save(); };

q('.del').onclick=()=>{ scenario.treatments.splice(i,1); save(); };


    host.appendChild(box);
  });
  buildTxButtons();
}

  /* ---- Prompt UI ---- */
  function drawAudioEditor(){
  const host = byId('audio-list'); if (!host) return;
  host.innerHTML = '';
  (scenario.audios||[]).forEach((a,i)=>{
    // defaults
    a.bg    = a.bg    || '#fafafa';
    a.bgOn  = a.bgOn  || '#c7f7c7';
    a.flashOn = !!a.flashOn;
    const footnoteText = normalizeAudioFootnote(a);

    const row = document.createElement('div');
    row.className = 'audio-row kv';
    row.dataset.id = a.id || `aud${i+1}`;
    if (!a.id) a.id = row.dataset.id;
    const displayName = formatAudioDisplayName(a) || 'No file chosen';
    const loopOnStart = !!a.loopOnStart;
    const loopDurationSec = Math.max(0, Math.floor(+a.loopOnStartFor || 0));
    const loopDurationStr = loopDurationSec ? fmt(loopDurationSec) : '';
    const volume = normalizeAudioVolume(a.volume);
    const footnoteTextValue = escapeAttr(footnoteText);
    const footnoteLabelValue = footnoteTextValue; // legacy alias for cached templates
    void footnoteLabelValue;
    row.innerHTML = `
      <div class="row hdr" style="gap:10px;align-items:center;flex-wrap:wrap">
        <label style="flex:2;min-width:180px">Label
          <input class="a-label" type="text" value="${a.label||`Audio ${i+1}`}" placeholder="Button label">
        </label>

        <label style="flex:1;min-width:200px">Library
          <select class="a-library"></select>
        </label>

        <div class="a-volume-field" title="Set playback volume for this cue">
          <span class="a-volume-label">Volume</span>
          <input class="a-volume" type="range" min="0" max="100" step="1" value="${volume}" aria-label="Volume">
          <span class="a-volume-value">${volume}%</span>
        </div>

        <button type="button" class="btn pick">Upload file…</button>
        <span class="audio-name">${displayName}</span>
        <input class="a-file" type="file" accept="audio/*" style="display:none">

        <label style="flex:0" title="Background color when OFF">
          BG <input class="a-bg" type="color" value="${a.bg}"
             style="width:46px;padding:0;border:0;background:transparent">
        </label>

        <label style="flex:0" title="Background color when ON">
          BG On <input class="a-bg-on" type="color" value="${a.bgOn}"
             style="width:60px;padding:0;border:0;background:transparent">
        </label>

        <label style="flex:0" title="Flash between BG On and BG while playing">
          Flash <input class="a-flash-on" type="checkbox" ${a.flashOn ? 'checked' : ''}>
        </label>

        <button type="button" class="btn danger del">Delete</button>
      </div>
      <div class="row auto" style="gap:10px;align-items:center;flex-wrap:wrap;margin-top:6px">
        <label style="display:flex;align-items:center;gap:6px;flex:0 0 auto">
          <input class="a-auto-loop" type="checkbox" ${loopOnStart ? 'checked' : ''}>
          <span>Loop automatically on Start</span>
        </label>
        <label style="display:flex;align-items:center;gap:6px;flex:0 0 auto" title="Accepts mm:ss or total seconds">
          <span>Duration</span>
          <input class="a-loop-duration" type="text" value="${loopDurationStr}" placeholder="mm:ss" style="width:80px">
        </label>
        <label style="display:flex;align-items:center;gap:6px;flex:0 1 260px">
          <span>Stop when treatment activates</span>
          <select class="a-loop-stop" title="Choose a treatment that stops this auto-loop when activated"></select>
        </label>
        <span class="muted" style="flex:1 1 auto;min-width:200px">Audio loops after Start until the duration expires or the selected treatment activates. Add treatments below to populate this list.</span>
      </div>
      <div class="row footnote" style="gap:10px;align-items:flex-start;flex-wrap:wrap;margin-top:6px">
        <label style="display:flex;flex-direction:column;gap:4px;flex:1 1 320px;min-width:220px">
          <span>Footnote text (bold under play button)</span>
          <input class="a-footnote-text" type="text" value="${footnoteTextValue}" placeholder="Shown under play button" maxlength="160">
        </label>
        <span class="muted" style="flex:1 1 100%;font-size:12px">Footnote appears beneath the audio button on the play screen.</span>
      </div>
    `;

    const labelEl = row.querySelector('.a-label');
    const pickBtn = row.querySelector('.pick');
    const fileEl  = row.querySelector('.a-file');
    const nameEl  = row.querySelector('.audio-name');
    const libEl   = row.querySelector('.a-library');
    const volumeEl = row.querySelector('.a-volume');
    const volumeValueEl = row.querySelector('.a-volume-value');
    const bgEl    = row.querySelector('.a-bg');
    const bgOnEl  = row.querySelector('.a-bg-on');
    const flashEl = row.querySelector('.a-flash-on');
    const autoLoopEl = row.querySelector('.a-auto-loop');
    const durationEl = row.querySelector('.a-loop-duration');
    const stopEl = row.querySelector('.a-loop-stop');
    const footnoteTextEl = row.querySelector('.a-footnote-text');

    if (volumeEl){
      const syncVolume = (shouldSave)=>{
        const rec = (scenario.audios||[])[i];
        if (!rec) return;
        const vol = normalizeAudioVolume(volumeEl.value);
        if (volumeValueEl) volumeValueEl.textContent = `${vol}%`;
        if (vol === DEFAULT_AUDIO_VOLUME){
          delete rec.volume;
        } else {
          rec.volume = vol;
        }
        if (currentAudioIdx === i){
          const audioEl = byId('p-audio');
          if (audioEl) applyAudioVolume(audioEl, rec);
        }
        if (shouldSave) save({skipRedraw:true});
      };
      volumeEl.addEventListener('input', ()=>syncVolume(false));
      volumeEl.addEventListener('change', ()=>syncVolume(true));
    }

    if (autoLoopEl){
      autoLoopEl.addEventListener('change', ()=>{
        const rec = (scenario.audios||[])[i];
        if (!rec) return;
        rec.loopOnStart = !!autoLoopEl.checked;
        const hasDuration = +rec.loopOnStartFor > 0;
        const hasStopTx = !!rec.loopStopOnTreatment;
        if (rec.loopOnStart && !hasDuration && !hasStopTx){
          rec.loopOnStartFor = 60;
          if (durationEl){
            durationEl.value = fmt(rec.loopOnStartFor);
          }
        }
        save();
      });
    }

    if (durationEl){
      const syncDuration = ()=>{
        const rec = (scenario.audios||[])[i];
        if (!rec) return;
        const seconds = parseTimeFlexible(durationEl.value);
        if (seconds > 0){
          rec.loopOnStartFor = seconds;
          durationEl.value = fmt(seconds);
        } else {
          delete rec.loopOnStartFor;
          durationEl.value = '';
        }
        save();
      };
      durationEl.addEventListener('change', syncDuration);
      durationEl.addEventListener('blur', syncDuration);
    }

    if (stopEl){
      populateStopTreatmentOptions(stopEl, (a.loopStopOnTreatment || '').trim() || '');
      stopEl.addEventListener('change', ()=>{
        const rec = (scenario.audios||[])[i];
        if (!rec) return;
        const choice = (stopEl.value || '').trim();
        if (choice){
          rec.loopStopOnTreatment = choice;
        } else {
          delete rec.loopStopOnTreatment;
        }
        if (rec.loopOnStart && !(+rec.loopOnStartFor > 0) && !rec.loopStopOnTreatment){
          rec.loopOnStartFor = 60;
          if (durationEl){
            durationEl.value = fmt(rec.loopOnStartFor);
          }
        }
        save();
      });
    }

    populateAudioLibraryOptions(libEl, a);

    if (footnoteTextEl){
      footnoteTextEl.addEventListener('input', ()=>{
        const rec = (scenario.audios||[])[i];
        if (!rec) return;
        const text = (footnoteTextEl.value || '').trim();
        if (text){
          rec.footnoteText = text;
        } else {
          delete rec.footnoteText;
        }
        save();
      });
    }

    // Update label live
    labelEl.addEventListener('input', ()=>{
      (scenario.audios||[])[i].label = labelEl.value?.trim() || `Audio ${i+1}`;
      save();
    });

    // File picker
    pickBtn.addEventListener('click', ()=> fileEl.click());
    fileEl.addEventListener('change', async ()=>{
      const f = fileEl.files?.[0]; if (!f) return;
      const existing = (scenario.audios||[])[i] || {};
      if (existing._objectUrl && existing._objectUrl.startsWith('blob:')){
        try{ URL.revokeObjectURL(existing._objectUrl); }catch{}
      }
      nameEl.textContent = f.name;
      if (libEl) libEl.value = '';

      // Create a temporary object URL for playback (do NOT store full file in localStorage)
      const objURL = URL.createObjectURL(f);

      (scenario.audios||[])[i] = {
        ...existing,
        id: row.dataset.id || `aud${i+1}`,
        label: labelEl.value?.trim() || f.name || `Audio ${i+1}`,
        url: objURL,         // use the object URL at runtime
        _objectUrl: objURL,  // mark as volatile (don’t persist)
        name: f.name,
        bg: (scenario.audios?.[i]?.bg)||'#fafafa',
        bgOn: (scenario.audios?.[i]?.bgOn)||'#c7f7c7',
        flashOn: !!(scenario.audios?.[i]?.flashOn)
        // no .data here on purpose
      };

      save();
    });

    if (libEl){
      libEl.addEventListener('change', ()=>{
        const choice = libEl.value;
        const rec = (scenario.audios||[])[i];
        if (!rec) return;
        if (choice){
          if (rec._objectUrl && rec._objectUrl.startsWith('blob:')){
            try{ URL.revokeObjectURL(rec._objectUrl); }catch{}
          }
          delete rec._objectUrl;
          delete rec.data;
          rec.url = choice;
          rec.name = audioLibraryLabel(choice) || '';
          nameEl.textContent = rec.name || 'No file chosen';
        } else {
          if (rec._objectUrl && rec._objectUrl.startsWith('blob:')){
            try{ URL.revokeObjectURL(rec._objectUrl); }catch{}
          }
          delete rec._objectUrl;
          delete rec.data;
          rec.url = '';
          rec.name = '';
          nameEl.textContent = 'No file chosen';
        }
        save();
      });
    }

    // Colors + flash
    bgEl.addEventListener('change', ()=>{
      (scenario.audios||[])[i].bg = bgEl.value || '#fafafa';
      save();
    });
    bgOnEl.addEventListener('change', ()=>{
      (scenario.audios||[])[i].bgOn = bgOnEl.value || '#c7f7c7';
      save();
    });
    flashEl.addEventListener('change', ()=>{
      (scenario.audios||[])[i].flashOn = !!flashEl.checked;
      save();
    });

    // Delete row
    row.querySelector('.del').addEventListener('click', ()=>{
      const rec = (scenario.audios||[])[i];
      if (rec && rec._objectUrl && rec._objectUrl.startsWith('blob:')){
        try{ URL.revokeObjectURL(rec._objectUrl); }catch{}
      }
      (scenario.audios||[]).splice(i,1);
      if (currentAudioIdx === i) currentAudioIdx = -1;
      else if (currentAudioIdx > i) currentAudioIdx -= 1;
      save();
      drawAudioEditor();
    });

    host.appendChild(row);
  });
  renderAudioButtons();
}

function renderAudioButtons(){
  const host = byId('p-audio-buttons'); if (!host) return;
  host.innerHTML = '';
  (scenario.audios||[]).forEach((a,i)=>{
    const src = getAudioSrc(a);
    // ensure defaults
    a.bg    = a.bg    || '#fafafa';
    a.bgOn  = a.bgOn  || '#c7f7c7';
    a.flashOn = !!a.flashOn;
    const footnoteText = normalizeAudioFootnote(a);
    const volume = normalizeAudioVolume(a.volume);
    if (volume === DEFAULT_AUDIO_VOLUME){
      delete a.volume;
    } else {
      a.volume = volume;
    }

    const btn = document.createElement('button');
    btn.className = 'btn';
    btn.dataset.audio = String(i);            // index for handler
    btn.textContent = a.label || `Audio ${i+1}`;
    if (!src){
      btn.classList.add('muted');
      btn.disabled = true;
      btn.title = 'Attach audio in Build';
    } else {
      btn.disabled = false;
      btn.classList.remove('muted');
      const desc = describeAudioAutoLoop(a);
      btn.title = desc || '';
    }

    // set CSS variables for flash animation (reuse treatment style)
    btn.style.setProperty('--on',  a.bgOn);
    btn.style.setProperty('--off', a.bg);

    // set initial background/flash based on playing state
    const playing = (i === currentAudioIdx);
    if (playing){
      if (a.flashOn){
        btn.classList.add('tflash');
        btn.style.background = '';
      } else {
        btn.classList.remove('tflash');
        btn.style.background = a.bgOn;
      }
    } else {
      btn.classList.remove('tflash');
      btn.style.background = a.bg;
    }

    const wrap = document.createElement('div');
    wrap.className = 'audio-btn-wrap';
    wrap.appendChild(btn);

    if (footnoteText){
      const note = document.createElement('div');
      note.className = 'audio-footnote';
      const textEl = document.createElement('strong');
      textEl.className = 'audio-footnote-text';
      textEl.textContent = footnoteText;
      note.appendChild(textEl);
      wrap.appendChild(note);
    }

    host.appendChild(wrap);
  });
}
function updateAudioButtonStates(){
  const host = byId('p-audio-buttons'); if (!host) return;
  const btns = Array.from(host.querySelectorAll('button[data-audio]'));
  btns.forEach(btn=>{
    const i = +btn.dataset.audio;
    const a = (scenario.audios||[])[i];
    if (!a) return;
    const playing = (i === currentAudioIdx);
    const src = getAudioSrc(a);

    if (!src){
      btn.disabled = true;
      btn.classList.add('muted');
      btn.title = 'Attach audio in Build';
    } else {
      btn.disabled = false;
      btn.classList.remove('muted');
      const desc = describeAudioAutoLoop(a);
      btn.title = desc || '';
    }

    // ensure vars in case colors changed
    btn.style.setProperty('--on',  a.bgOn || '#c7f7c7');
    btn.style.setProperty('--off', a.bg   || '#fafafa');

    if (playing){
      if (a.flashOn){
        btn.classList.add('tflash');
        btn.style.background = '';
      } else {
        btn.classList.remove('tflash');
        btn.style.background = a.bgOn || '#c7f7c7';
      }
    } else {
      btn.classList.remove('tflash');
      btn.style.background = a.bg || '#fafafa';
    }
  });
}

/* ---- Injects UI ---- */
function drawInjects(){
  const host = byId('inject-list'); if(!host) return; host.innerHTML = '';
  const now = elapsed|0;

  (scenario.injects||[]).forEach((inj,i)=>{
    // ensure defaults
    inj.id = inj.id || `inj${i+1}`;
    const dur = inj.dur ?? 0;
    const hide = inj.hideAfter ?? dur;
    ensureInjectBeepDefaultsFor(inj);

    const scheduledSec = Math.max(0, (+inj.t||0));
    const scheduledStr = fmt(scheduledSec);
    const untilSec = Math.max(0, scheduledSec - now);
    const untilStr = fmt(untilSec);

    const row = document.createElement('div'); row.className='row inject-row';

    row.innerHTML = `
      <span class="badge">#${i+1}</span>

      <label class="inject-field name-field" title="Name shown in the inject list">
        <span class="label-title">Name</span>
        <input class="name" value="${inj.name||''}" placeholder="Inject name">
      </label>

      <div class="kv until-group" title="Scheduled fire time and remaining countdown">
        <span class="label-title">Timing</span>
        <div class="pill" title="Time remaining until this inject fires">${untilStr}</div>
        <span class="saved-time" title="Saved fire time">Scheduled ${scheduledStr}</span>
        <button type="button" class="btn set-time" title="Set scheduled time (currently ${scheduledStr})">Set time</button>
      </div>

      <label class="inject-field duration-field" title="Seconds visible after firing">
        <span class="label-title">Duration (s)</span>
        <input class="dur" type="number" min="0" value="${dur}">
      </label>

      <label class="inject-field hide-field" title="Seconds after firing to remove; default equals duration">
        <span class="label-title">Hide after (s)</span>
        <input class="hide" type="number" min="0" value="${hide}">
      </label>

      <label class="inject-field color-field" title="Background color for this inject">
        <span class="label-title">BG</span>
        <input class="bg" type="color" value="${inj.bg || '#eef2ff'}">
      </label>

      <label class="inject-field tx-field" title="Comma list of Treatment IDs to turn ON when this inject fires">
        <span class="label-title">Tx on fire</span>
        <input class="txon" placeholder="txA,txB" value="${(inj.txOn||[]).join(',')}">
      </label>

      <div class="kv inj-beep-wrap">
        <label title="Beep pattern when this inject starts">
          <span class="label-title">Start beep</span>
          <select class="inj-beep">
            <option value="none">No audio</option>
            <option value="1short">One short</option>
            <option value="1long">One long</option>
            <option value="2short">Two short</option>
            <option value="3short">Three short</option>
          </select>
        </label>
        <button type="button" class="btn inj-beep-preview" title="Preview start beep">Preview start</button>
        <label title="Beep pattern when this inject duration ends (650 Hz)">
          <span class="label-title">End beep</span>
          <select class="inj-end-beep">
            <option value="none">No audio</option>
            <option value="1short">One short</option>
            <option value="1long">One long</option>
            <option value="2short">Two short</option>
            <option value="3short">Three short</option>
          </select>
        </label>
        <button type="button" class="btn inj-end-beep-preview" title="Preview end beep">Preview end</button>
      </div>

      <label class="switch start-next-field" title="Manually start next inject’s countdown now">
        <input type="checkbox" class="start-next">
        <span>Start next now</span>
      </label>

      <button class="btn danger del" type="button">Delete</button>
    `;

    // Handlers
    row.querySelector('.name').onchange = e => { inj.name = e.target.value; save(); };

    row.querySelector('.set-time').onclick = () => {
      const defaultVal = scheduledStr;
      const v = prompt('Set time (mm:ss or seconds):', defaultVal);
      if (v == null) return;
      const seconds = parseTimeFlexible(v);
      const err = byId('inj-error');
      if (seconds >= 0){
        inj.t = seconds;
        if (err) err.textContent = '';
        save();
      } else {
        if (err) err.textContent = 'Invalid time. Use mm:ss or seconds.';
      }
    };

    row.querySelector('.dur').onchange = e => {
      inj.dur = Math.max(0, parseInt(e.target.value||'0',10));
      if (inj.hideAfter == null) inj.hideAfter = inj.dur;
      save();
    };
    row.querySelector('.bg').onchange = e => {
        inj.bg = e.target.value; // hex string like #aabbcc
        save();
    };

    row.querySelector('.hide').onchange = e => {
      inj.hideAfter = Math.max(0, parseInt(e.target.value||'0',10));
      save();
    };
    row.querySelector('.txon').onchange = e => {
        inj.txOn = String(e.target.value || '')
            .split(',')
            .map(s => s.trim())
            .filter(Boolean);
        save();
    };

    const txAutoOff = row.querySelector('.tx-auto-off');
    if (txAutoOff){
      txAutoOff.checked = inj.txAutoOff !== false;
      txAutoOff.onchange = () => {
        inj.txAutoOff = !!txAutoOff.checked;
        save();
      };
    }

    const startSel = row.querySelector('.inj-beep');
    const startPrevBtn = row.querySelector('.inj-beep-preview');
    const endSel = row.querySelector('.inj-end-beep');
    const endPrevBtn = row.querySelector('.inj-end-beep-preview');

    if (startSel && endSel){
      startSel.value = inj.beepPattern || DEFAULT_BEEP_PATTERN;
      endSel.value = inj.endBeepPattern || inj.beepPattern || DEFAULT_BEEP_PATTERN;

      const syncPreviewState = () => {
        if (startPrevBtn) startPrevBtn.disabled = (startSel.value === NO_BEEP_PATTERN);
        if (endPrevBtn) endPrevBtn.disabled = (endSel.value === NO_BEEP_PATTERN);
      };
      syncPreviewState();

      startSel.onchange = () => {
        const prevStart = inj.beepPattern || DEFAULT_BEEP_PATTERN;
        const prevEnd = inj.endBeepPattern || prevStart;
        inj.beepPattern = startSel.value;
        if (prevEnd === prevStart){
          inj.endBeepPattern = inj.beepPattern;
          endSel.value = inj.endBeepPattern;
        }
        save();
        syncPreviewState();
      };

      if (startPrevBtn){
        startPrevBtn.onclick = () => {
          playBeepPattern(inj.beepPattern || DEFAULT_BEEP_PATTERN, START_BEEP_FREQ);
        };
      }

      endSel.onchange = () => {
        inj.endBeepPattern = endSel.value;
        save();
        syncPreviewState();
      };

      if (endPrevBtn){
        endPrevBtn.onclick = () => {
          const pat = inj.endBeepPattern || inj.beepPattern || DEFAULT_BEEP_PATTERN;
          playBeepPattern(pat, END_BEEP_FREQ);
        };
      }
    }

    // Manual chain start
    const startNext = row.querySelector('.start-next');
    startNext.onchange = () => {
      if (startNext.checked){
        startNextInject(inj.id);
        // keep checked to indicate it was used
        startNext.disabled = true;
      }
    };

    row.querySelector('.del').onclick = () => {
      scenario.injects.splice(i,1);
      save();
    };

    host.appendChild(row);
  });
}

function addInject(){
  const tStr=byId('inj-time').value;
  const seconds=parseTimeFlexible(tStr);
  if (seconds<0){ byId('inj-error').textContent='Time must be mm:ss or seconds (e.g., 8:0, 08:00, 480, 90).'; return; }
  byId('inj-error').textContent='';
  const name=byId('inj-name').value||'Inject';
  scenario.injects.push({
    id:`inj${Date.now()}`,
    t:seconds,
    name,
    dur:30,        // default visible 30 s after firing
    hideAfter:30,  // default hide at same time as duration
    triggers:[],
    txAutoOff:true,
    beepPattern: DEFAULT_BEEP_PATTERN,
    endBeepPattern: DEFAULT_BEEP_PATTERN
  });
  save();
}

function applyInjects(){
  ensureInjectListDefaults(scenario.injects);
  appliedInjects=[...(scenario.injects||[])].sort((a,b)=>a.t-b.t);
  firedInject.clear();
  triggeredOnce.clear();
  lastActiveInjectKey = null;
  lastActiveInjectRef = null;
  renderInjects();
  log('Applied injects to current run.');
}

/* ---------------- Persistence + wiring ---------------- */
function save(options){
  const opts = options || {};
  // gather form
  const mt=byId('meta-title'); if(mt) scenario.meta.title=mt.value;
  const ma=byId('meta-author'); if(ma) scenario.meta.author=ma.value;
  const td=byId('txt-dispatch'); if(td) scenario.text.dispatch=td.value;
  const tgi=byId('txt-gi'); if(tgi) scenario.text.gi=tgi.value;
  const tav=byId('txt-avpu'); if(tav) scenario.text.avpu=tav.value;
  const tno=byId('txt-noi'); if(tno) scenario.text.noi=tno.value;
  const tcs=byId('txt-cspine'); if(tcs) scenario.text.cspine=tcs.value;
  const tbs=byId('txt-backstory'); if(tbs) scenario.text.backstory=tbs.value;
  const ttp=byId('txt-talkingpoints'); if(ttp) scenario.text.talkingPoints=ttp.value;
  const the=byId('txt-hospital-eta'); if(the) scenario.text.hospitalEta=(the.value||'').trim()||'—';
  scenario.flags.als=byId('flag-als-build')?.checked||byId('flag-als-play')?.checked||false;
  scenario.timing.minutes=parseInt(byId('min')?.value||'15',10);

  scenario.vitals.hr=+byId('v-hr').value; scenario.vitals.rr=+byId('v-rr').value;
  scenario.vitals.spo2=+byId('v-spo2').value; scenario.vitals.sbp=+byId('v-sbp').value;
  scenario.vitals.dbp=+byId('v-dbp').value; scenario.vitals.cbg=+byId('v-cbg').value;

  // descriptors + skin
  scenario.vitals.hrRate=byId('v-hr-rate')?.value||scenario.vitals.hrRate;
  scenario.vitals.hrRhythm=byId('v-hr-rhythm')?.value||scenario.vitals.hrRhythm;
  scenario.vitals.hrQuality=byId('v-hr-quality')?.value||scenario.vitals.hrQuality;
  scenario.vitals.rrRate=byId('v-rr-rate')?.value||scenario.vitals.rrRate;
  scenario.vitals.rrRhythm=byId('v-rr-rhythm')?.value||scenario.vitals.rrRhythm;
  scenario.vitals.rrQuality=byId('v-rr-quality')?.value||scenario.vitals.rrQuality;
  scenario.vitals.skinColor=byId('v-skin-color')?.value||scenario.vitals.skinColor;
  scenario.vitals.skinTemp=byId('v-skin-temp')?.value||scenario.vitals.skinTemp;
  scenario.vitals.skinMoist=byId('v-skin-moist')?.value||scenario.vitals.skinMoist;

  // SAMPLE
  scenario.sample.s=byId('s-s')?.value||scenario.sample.s;
  scenario.sample.a=byId('s-a')?.value||scenario.sample.a;
  scenario.sample.m=byId('s-m')?.value||scenario.sample.m;
  scenario.sample.p=byId('s-p')?.value||scenario.sample.p;
  scenario.sample.l=byId('s-l')?.value||scenario.sample.l;
  scenario.sample.e=byId('s-e')?.value||scenario.sample.e;
  scenario.sample.phys=byId('phys')?.value||scenario.sample.phys;

  // OPQRST
  scenario.opqrst = scenario.opqrst || {o:"",p:"",q:"",r:"",s:"",t:""};
  scenario.opqrst.o = byId('o-o')?.value || scenario.opqrst.o;
  scenario.opqrst.p = byId('o-p')?.value || scenario.opqrst.p;
  scenario.opqrst.q = byId('o-q')?.value || scenario.opqrst.q;
  scenario.opqrst.r = byId('o-r')?.value || scenario.opqrst.r;
  scenario.opqrst.s = byId('o-s')?.value || scenario.opqrst.s;
  scenario.opqrst.t = byId('o-t')?.value || scenario.opqrst.t;

  // Audio cues (list) — keep existing files; only update labels from UI
  {
    const host = byId('audio-list');
    if (host){
      const rows = Array.from(host.querySelectorAll('.audio-row'));
      rows.forEach((row,i)=>{
        const label = row.querySelector('.a-label')?.value?.trim();
        const volumeValue = row.querySelector('.a-volume')?.value;
        const volume = normalizeAudioVolume(volumeValue);
        const footnoteText = row.querySelector('.a-footnote-text')?.value?.trim();
        if (scenario.audios[i]){
          scenario.audios[i].label = label || scenario.audios[i].label || `Audio ${i+1}`;
          if (volume === DEFAULT_AUDIO_VOLUME){
            delete scenario.audios[i].volume;
          } else {
            scenario.audios[i].volume = volume;
          }
          if (footnoteText){
            scenario.audios[i].footnoteText = footnoteText;
          } else {
            delete scenario.audios[i].footnoteText;
          }
        }
      });
    }
  }

  document.querySelectorAll('#audio-list .audio-row').forEach((row, idx) => {
    const select = row.querySelector('.a-loop-stop');
    if (!select) return;
    const rec = (scenario.audios || [])[idx];
    const selected = (rec && rec.loopStopOnTreatment) ? String(rec.loopStopOnTreatment).trim() : '';
    populateStopTreatmentOptions(select, selected);
  });

  // Display toggles
  scenario.displayOnPlay = scenario.displayOnPlay || {};
  document.querySelectorAll('input[data-display-key]').forEach(cb=>{
    const key = cb.dataset.displayKey;
    if (!key) return;
    scenario.displayOnPlay[key] = !!cb.checked;
  });

try{
  localStorage.setItem('emtScenarioRunnerV27', JSON.stringify(scenarioForStorage()));
  const a=byId('autosave'); if(a){ a.textContent='saved'; setTimeout(()=>a.textContent='idle',700); }
}catch(e){
  console.warn('Autosave skipped (likely storage full):', e);
  const a=byId('autosave'); if(a){ a.textContent='storage full'; }
}
  const a=byId('autosave'); if(a){ a.textContent='saved'; setTimeout(()=>a.textContent='idle',700); }
  if (!opts.skipRedraw){
    drawInjects();
    drawTreatments();
    buildTxButtons();
    if (typeof buildNbTxButtons === 'function'){
      buildNbTxButtons();
    }
    renderAudioButtons();
    renderAll();
  }
}
function load(){
  const raw=localStorage.getItem('emtScenarioRunnerV27'); if(raw){ try{ scenario=JSON.parse(raw); }catch{} }
  ensureScenarioDefaults();
  // seed UI
  byId('meta-title').value=scenario.meta.title||'';
  byId('meta-author').value=scenario.meta.author||'';
  byId('txt-dispatch').value=scenario.text.dispatch||'';
  byId('txt-gi').value=scenario.text.gi||'';
  byId('txt-avpu').value=scenario.text.avpu||'';
  byId('txt-noi').value=scenario.text.noi||'';
  byId('txt-cspine').value=scenario.text.cspine||'';
  const tb=byId('txt-backstory'); if(tb) tb.value=scenario.text.backstory||'';
  const tt=byId('txt-talkingpoints'); if(tt) tt.value=scenario.text.talkingPoints||'';
  const the=byId('txt-hospital-eta'); if(the) the.value=scenario.text.hospitalEta||'—';
  byId('min').value=scenario.timing.minutes||15;

  document.querySelectorAll('input[data-display-key]').forEach(cb=>{
    const key = cb.dataset.displayKey;
    cb.checked = scenario.displayOnPlay?.[key] !== false;
  });

  byId('v-hr').value=scenario.vitals.hr; byId('v-rr').value=scenario.vitals.rr; byId('v-spo2').value=scenario.vitals.spo2;
  byId('v-sbp').value=scenario.vitals.sbp; byId('v-dbp').value=scenario.vitals.dbp; byId('v-cbg').value=scenario.vitals.cbg;

  const setVal=(id,val)=>{ const el=byId(id); if(el) el.value=val||el.value; };
  setVal('v-hr-rate', scenario.vitals.hrRate);
  setVal('v-hr-rhythm', scenario.vitals.hrRhythm);
  setVal('v-hr-quality', scenario.vitals.hrQuality);
  setVal('v-rr-rate', scenario.vitals.rrRate);
  setVal('v-rr-rhythm', scenario.vitals.rrRhythm);
  setVal('v-rr-quality', scenario.vitals.rrQuality);
  setVal('v-skin-color', scenario.vitals.skinColor);
  setVal('v-skin-temp', scenario.vitals.skinTemp);
  setVal('v-skin-moist', scenario.vitals.skinMoist);

  if (scenario.apgarNotes){
    Object.entries(scenario.apgarNotes.one || {}).forEach(([k,val])=>{
      const el = byId(`apgar1note-${k}`);
      if (el) el.value = val || '';
    });
    Object.entries(scenario.apgarNotes.five || {}).forEach(([k,val])=>{
      const el = byId(`apgar5note-${k}`);
      if (el) el.value = val || '';
    });
  }

  if(!scenario.opqrst) scenario.opqrst = {o:"",p:"",q:"",r:"",s:"",t:""};
    const setInput = (id,val)=>{ const el=byId(id); if(el) el.value = val || ''; };
    setInput('o-o', scenario.opqrst.o);
    setInput('o-p', scenario.opqrst.p);
    setInput('o-q', scenario.opqrst.q);
    setInput('o-r', scenario.opqrst.r);
    setInput('o-s', scenario.opqrst.s);
    setInput('o-t', scenario.opqrst.t);
  // migrate single -> list once
  if (!scenario.audios) scenario.audios = [];
  if (scenario.audio && (scenario.audio.label || scenario.audio.url)){
    scenario.audios.push({
      id:`aud${Date.now()}`,
      label: scenario.audio.label || 'Audio',
      url: scenario.audio.url || ''
    });
    delete scenario.audio;
  }
  drawAudioEditor();   // build list UI

  hydrateBuilderInputs();
  drawInjects(); drawTreatments(); buildTxButtons();
  renderPresetButtons();
  resetRun();
}
function wire(){
  // mode
  safeOn(byId('mode-build'),'click',()=>{ byId('build').classList.remove('hidden'); byId('play').classList.add('hidden'); renderAll(); });
  safeOn(byId('mode-play'),'click',()=>{ byId('build').classList.add('hidden'); byId('play').classList.remove('hidden'); renderAll(); });
  // run
  safeOn(byId('start'),'click',start); safeOn(byId('pause'),'click',pause); safeOn(byId('reset'),'click',resetRun);
  safeOn(byId('p-start'),'click',start); safeOn(byId('p-pause'),'click',pause); safeOn(byId('p-reset'),'click',resetRun);
   const audioBtnsHost = byId('p-audio-buttons');
if (audioBtnsHost){
  audioBtnsHost.addEventListener('click', async (e)=>{
    const b = e.target.closest('button[data-audio]');
    if (!b) return;
    const idx = +b.dataset.audio;
    const rec = (scenario.audios||[])[idx];
    const el  = byId('p-audio');
    const src = getAudioSrc(rec);
    if (!rec || !src || !el){ alert('No audio file set for this button.'); return; }
    clearAutoLoopTimer(true);
    if (el.src !== src) el.src = src;
    el.loop = audioLoop;
    applyAudioVolume(el, rec);
    try{
      el.currentTime = 0;
      await el.play();
      currentAudioIdx = idx;
      updateAudioButtonStates();
    }catch(err){
      console.warn('Audio play failed:', err);
      alert('Browser blocked autoplay. Click once on the page, then try again.');
    }
  });
}
  // When audio naturally ends, reset button states so flashing stops
  safeOn(byId('p-audio'), 'ended', () => {
    const el = byId('p-audio');
    if (el && el.loop){
      return;
    }
    currentAudioIdx = -1;
    if (el) el.currentTime = 0;
    clearAutoLoopTimer(true);
    updateAudioButtonStates();
  });

  // STOP button
  safeOn(byId('p-audio-stop'), 'click', () => {
    const el = byId('p-audio');
    if (!el) return;
    clearAutoLoopTimer(true);
    el.pause();
    el.currentTime = 0;
    currentAudioIdx = -1;
    updateAudioButtonStates();
  });

  // LOOP toggle
  safeOn(byId('p-audio-loop'), 'click', () => {
    audioLoop = !audioLoop;
    const el = byId('p-audio');
    if (el) el.loop = audioLoop;
    setLoopButtonState(audioLoop);
    if (autoLoopTimer || autoLoopRestore !== null){
      autoLoopRestore = audioLoop;
    }
});

safeOn(byId('urgent-close'),'click',closeUrgent);
safeOn(byId('urgent-backdrop'),'click',closeUrgent);

// BUILD: add-audio button
safeOn(byId('add-audio'),'click',()=>{
  scenario.audios = scenario.audios || [];
  const nextIndex = scenario.audios.length + 1;
  scenario.audios.push({
    id:`aud${Date.now()}`,
    label:`Audio ${nextIndex}`,
    url:'',
    name:'',
    bg:'#fafafa',
    bgOn:'#c7f7c7',
    flashOn:false,
    loopOnStart:false
  });
  save();
  drawAudioEditor();
});


  // ALS
  safeOn(byId('flag-als-build'),'change',()=>{ scenario.flags.als=byId('flag-als-build').checked; const cp=byId('flag-als-play'); if(cp) cp.checked=scenario.flags.als; save(); });
  safeOn(byId('flag-als-play'),'change',()=>{ scenario.flags.als=byId('flag-als-play').checked; const cb=byId('flag-als-build'); if(cb) cb.checked=scenario.flags.als; save(); });
  // inputs
  ['meta-title','meta-author','txt-dispatch','txt-gi','txt-avpu','txt-noi','txt-cspine','txt-hospital-eta','min',
  'v-hr','v-rr','v-spo2','v-sbp','v-dbp','v-cbg',
  's-s','s-a','s-m','s-p','s-l','s-e','phys',
  'o-o','o-p','o-q','o-r','o-s','o-t','audio-label','audio-url',
  'v-hr-rate','v-hr-rhythm','v-hr-quality','v-rr-rate','v-rr-rhythm','v-rr-quality','v-skin-color','v-skin-temp','v-skin-moist']
  .forEach(id=> safeOn(byId(id),'input',save));
  document.querySelectorAll('input[data-display-key]').forEach(el=> safeOn(el,'change',save));

  // adders
  safeOn(byId('add-tx'),'click',()=>{ scenario.treatments.push({id:`tx${Date.now()}`,label:"New Treatment",mode:"toggle",eff:{},cap:{}}); save(); });
  safeOn(byId('add-inject'),'click',addInject);
  safeOn(byId('apply-injects'),'click',applyInjects);
  // export/import
  safeOn(byId('export'),'click',()=>{
    const a=document.createElement('a');
    a.href=URL.createObjectURL(new Blob([JSON.stringify(scenario,null,2)],{type:'application/json'}));
    a.download=(scenario.meta.title||'scenario')+'.json';
    a.click();
  });
  safeOn(byId('import-label'),'click',()=> byId('import')?.click());
  safeOn(byId('import'),'change',(e)=>{
    const f=e.target.files[0]; if(!f) return;
    const r=new FileReader();
    r.onload=()=>{ try{
      scenario=JSON.parse(r.result);
      ensureScenarioDefaults();
      localStorage.setItem('emtScenarioRunnerV27', JSON.stringify(scenario));
      hydrateBuilderInputs();
      load();
    }catch{ alert('Invalid JSON'); } };
    r.readAsText(f);
  });
  ['gh-owner','gh-repo','gh-branch','gh-path','gh-token','gh-committer-name','gh-committer-email','gh-filename']
    .forEach(id => safeOn(byId(id),'change',()=>{
      const cfg = getGitHubConfig();
      const file = byId('gh-filename')?.value?.trim() || '';
      persistGitHubConfig({ ...cfg, lastSelected: githubState.lastSelected || '', lastFile: file });
    }));
    safeOn(byId('gh-refresh'),'click',refreshGitHubScenarios);
    safeOn(byId('gh-save'),'click',saveScenarioToGitHub);
    safeOn(byId('gh-load'),'click',loadScenarioFromGitHub);
    const onScenarioSelectChange = (e)=>{
      const value = e.target.value || '';
      githubState.lastSelected = value;
      if (value){
        const match = githubState.items.find(item=>item.path === value);
        const fileInput = byId('gh-filename');
        if (fileInput && match?.name) fileInput.value = match.name;
        rememberSelection(value, match?.name || fileInput?.value || '');
      }else{
        rememberSelection('', byId('gh-filename')?.value?.trim() || '');
      }
      setScenarioSelectValue(value);
    };
    scenarioSelects().forEach(select => safeOn(select,'change',onScenarioSelectChange));
} // <-- close wire()

function ensureScenarioDefaults(){
  scenario = scenario || {};
  scenario.meta = scenario.meta || JSON.parse(JSON.stringify(DEFAULT_SCENARIO.meta));
  scenario.text = scenario.text || {};
  scenario.text.dispatch ??= "";
  scenario.text.gi ??= "";
  scenario.text.avpu ??= "";
  scenario.text.noi ??= "";
  scenario.text.cspine ??= "";
  scenario.text.backstory ??= "";
  scenario.text.talkingPoints ??= "";
  scenario.text.hospitalEta ??= "—";
  scenario.flags = scenario.flags || {als:false};
  scenario.timing = scenario.timing || {minutes:15};
  scenario.injects = Array.isArray(scenario.injects) ? scenario.injects : [];
  ensureInjectListDefaults(scenario.injects);
  scenario.vitals = scenario.vitals || {};
  const v = scenario.vitals;
  if (v.skinColor == null)  v.skinColor = "normal";
  if (v.skinTemp == null)   v.skinTemp = "warm";
  if (v.skinMoist == null)  v.skinMoist = "dry";
  if (v.hrRate == null)     v.hrRate = "normal";
  if (v.hrRhythm == null)   v.hrRhythm = "regular";
  if (v.hrQuality == null)  v.hrQuality = "normal";
  if (v.rrRate == null)     v.rrRate = "normal";
  if (v.rrRhythm == null)   v.rrRhythm = "regular";
  if (v.rrQuality == null)  v.rrQuality = "normal";
  scenario.sample = scenario.sample || {s:"",a:"",m:"",p:"",l:"",e:"",phys:""};
  scenario.opqrst = scenario.opqrst || {o:"",p:"",q:"",r:"",s:"",t:""};
  scenario.audios = Array.isArray(scenario.audios) ? scenario.audios : [];
  scenario.audios.forEach(a=>{
    if (!a) return;
    normalizeAudioFootnote(a);
    if (Object.prototype.hasOwnProperty.call(a, 'volume')){
      const vol = normalizeAudioVolume(a.volume);
      if (vol === DEFAULT_AUDIO_VOLUME){
        delete a.volume;
      } else {
        a.volume = vol;
      }
    }
  });
  scenario.treatments = Array.isArray(scenario.treatments) ? scenario.treatments : [];
  scenario.prompts = Array.isArray(scenario.prompts) ? scenario.prompts : [];
  if (!scenario.apgar) scenario.apgar = JSON.parse(JSON.stringify(DEFAULT_SCENARIO.apgar));
  if (!scenario.apgarNotes) scenario.apgarNotes = JSON.parse(JSON.stringify(DEFAULT_SCENARIO.apgarNotes));
  if (!scenario.nbVitals) scenario.nbVitals = JSON.parse(JSON.stringify(DEFAULT_SCENARIO.nbVitals));
  if (!Array.isArray(scenario.nbTreatments)) scenario.nbTreatments = [];
  const defaultDisplay = DEFAULT_SCENARIO.displayOnPlay;
  scenario.displayOnPlay = scenario.displayOnPlay || {};
  Object.keys(defaultDisplay).forEach(key=>{
    if (scenario.displayOnPlay[key] == null) scenario.displayOnPlay[key] = defaultDisplay[key];
  });
}

function hydrateBuilderInputs(){
  const ids = {
    'txt-backstory': scenario.text.backstory,
    'txt-talkingpoints': scenario.text.talkingPoints,
    'txt-hospital-eta': scenario.text.hospitalEta,
    'nb-hr': scenario.nbVitals?.hr,
    'nb-rr': scenario.nbVitals?.rr,
    'nb-spo2': scenario.nbVitals?.spo2,
    'nb-sbp': scenario.nbVitals?.sbp,
    'nb-dbp': scenario.nbVitals?.dbp,
    'nb-cbg': scenario.nbVitals?.cbg,
    'nb-hr-rate': scenario.nbVitals?.hrRate,
    'nb-hr-rhythm': scenario.nbVitals?.hrRhythm,
    'nb-hr-quality': scenario.nbVitals?.hrQuality,
    'nb-rr-rate': scenario.nbVitals?.rrRate,
    'nb-rr-rhythm': scenario.nbVitals?.rrRhythm,
    'nb-rr-quality': scenario.nbVitals?.rrQuality,
    'nb-skin-color': scenario.nbVitals?.skinColor,
    'nb-skin-temp': scenario.nbVitals?.skinTemp,
    'nb-skin-moist': scenario.nbVitals?.skinMoist
  };
  Object.entries(ids).forEach(([id,val])=>{
    const el = byId(id);
    if (!el || val == null) return;
    if (el.type === 'checkbox') el.checked = !!val;
    else el.value = val;
  });

  if (scenario.apgarNotes){
    Object.entries(scenario.apgarNotes.one || {}).forEach(([k,val])=>{
      const el = byId(`apgar1note-${k}`);
      if (el) el.value = val || '';
    });
    Object.entries(scenario.apgarNotes.five || {}).forEach(([k,val])=>{
      const el = byId(`apgar5note-${k}`);
      if (el) el.value = val || '';
    });
  }
}

document.addEventListener('DOMContentLoaded', ()=>{
  ensureScenarioDefaults();
  hydrateGitHubConfig();
  setGitHubStatus('Enter GitHub owner, repository, and branch to manage remote scenarios.');
  wire();
  load();
  loadAudioLibrary().catch(err=>console.warn('Audio library init failed:', err));
  const cfg = getGitHubConfig();
  if (cfg.owner && cfg.repo){
    refreshGitHubScenarios();
  }
});
</script>
<!-- URGENT modal -->
<div id="urgent-modal" class="modal" aria-hidden="true">
  <div class="modal-backdrop" id="urgent-backdrop"></div>
  <div class="modal-card" role="dialog" aria-labelledby="urgent-title">
    <div class="modal-head" id="urgent-title">URGENT!</div>
    <div class="modal-body" id="urgent-message">—</div>
    <div class="modal-actions">
      <button id="urgent-close" class="btn">Close</button>
    </div>
</div>
</div>
<!-- Time to Hospital pill — paste just before </body> -->
<!-- Newborn Vitals → Play sync shim -->
<script>
(function(){
  "use strict";
  const byId=(id)=>document.getElementById(id);

  function syncNB(){
    if(!window.scenario || !scenario.nbVitals) return;
    const s=scenario.nbVitals;
    const set=(id,val)=>{ const el=byId(id); if(el) el.textContent=val; };
    set('np-hr', Number.isFinite(s.hr)? Math.round(s.hr):'--');
    set('np-rr', Number.isFinite(s.rr)? Math.round(s.rr):'--');
    set('np-spo2', Number.isFinite(s.spo2)? (+s.spo2).toFixed(1):'--');
    set('np-bp', (Number.isFinite(s.sbp)&&Number.isFinite(s.dbp))? `${Math.round(s.sbp)}/${Math.round(s.dbp)}`:'--/--');
    set('np-cbg', Number.isFinite(s.cbg)? Math.round(s.cbg):'--');
    const hrD=byId('np-hr-desc'); if(hrD) hrD.textContent = `Rate: ${s.hrRate||'normal'} | Rhythm: ${s.hrRhythm||'regular'} | Quality: ${s.hrQuality||'normal'}`;
    const rrD=byId('np-rr-desc'); if(rrD) rrD.textContent = `Rate: ${s.rrRate||'normal'} | Rhythm: ${s.rrRhythm||'regular'} | Quality: ${s.rrQuality||'normal'}`;
    const skin=byId('np-skin'); if(skin) skin.textContent = `${s.skinColor||'--'} / ${s.skinTemp||'--'} / ${s.skinMoist||'--'}`;
  }

  function wireBuildInputs(){
    const ids=['nb-hr','nb-rr','nb-spo2','nb-sbp','nb-dbp','nb-cbg','nb-hr-rate','nb-hr-rhythm','nb-hr-quality','nb-rr-rate','nb-rr-rhythm','nb-rr-quality','nb-skin-color','nb-skin-temp','nb-skin-moist'];
    ids.forEach(id=>{
      const el=byId(id); if(!el) return;
      const on=()=>{ try{ syncNB(); }catch{} };
      el.addEventListener('input', on);
      el.addEventListener('change', on);
    });
  }

  function patchRenderAll(){
    if (window._nbSyncPatched) return;
    if (typeof window.renderAll !== 'function'){ setTimeout(patchRenderAll,100); return; }
    window._nbSyncPatched = true;
    const orig = window.renderAll;
    window.renderAll = function(){
      orig();
      try{ syncNB(); }catch{}
    };
  }

  function boot(){
    patchRenderAll();
    wireBuildInputs();
    const wait = ()=>{ if(byId('np-hr')){ syncNB(); } else { setTimeout(wait,100); } };
    wait();
  }

  if (document.readyState==='complete' || document.readyState==='interactive') boot();
  else document.addEventListener('DOMContentLoaded', boot, {once:true});
})();
</script>

<!-- OBGYN Add-on v3 -->
<script>
(function(){
  "use strict";

  const byId = (id)=>document.getElementById(id);
  const h = (html)=>{ const t=document.createElement('template'); t.innerHTML=html.trim(); return t.content.firstElementChild; };

  function saveSafe(){
    try{ if(typeof save==="function"){ save(); return; } }catch{}
    try{ localStorage.setItem('emtScenarioRunnerV27', JSON.stringify(scenario)); }catch{}
  }

  const APGAR_DOMAINS = [
    ["appearance","Appearance (color)"],
    ["pulse","Pulse (HR)"],
    ["grimace","Grimace (reflex)"],
    ["activity","Activity (tone)"],
    ["respiration","Respiration"]
  ];

  function ensureScenarioExtensions(){
    ensureScenarioDefaults();
  }

  function mountBackstoryBuild(){
    if (byId('backstory-fields')) return;
    const csp = byId('txt-cspine'); if(!csp) return;
    const holder = csp.closest('.grid'); if(!holder) return;
    if (byId('obgyn-backstory-build')) return;
    const wrap = h(`
      <div id="obgyn-backstory-build" style="margin-top:8px">
        <div class="grid" style="display:grid;grid-template-columns:1fr 1fr;gap:12px">
          <label>Patient Backstory – Use to answer questions that may be asked
            <textarea id="txt-backstory" rows="3" placeholder="One line per bullet"></textarea>
          </label>
          <label>Inject talking points
            <textarea id="txt-talkingpoints" rows="3" placeholder="One line per bullet"></textarea>
          </label>
        </div>
      </div>
    `);
    holder.insertAdjacentElement('afterend', wrap);
    const elB = byId('txt-backstory');
    const elT = byId('txt-talkingpoints');
    if (elB) elB.value = scenario.text.backstory || "";
    if (elT) elT.value = scenario.text.talkingPoints || "";
    const bind = (el,key)=>{ if(!el) return; const on=()=>{ scenario.text[key]=el.value; saveSafe(); renderOBPlay(); }; el.addEventListener('input',on); el.addEventListener('change',on); };
    bind(elB,'backstory'); bind(elT,'talkingPoints');
  }

  function apgarSelect(namePrefix){
    const opts = [0,1,2].map(v=>`<option value="${v}">${v}</option>`).join("");
    return APGAR_DOMAINS.map(([k,label])=>`
      <label>${label}
        <select id="${namePrefix}-${k}">${opts}</select>
      </label>
    `).join("");
  }

  function apgarNoteInputs(idPrefix){
    return APGAR_DOMAINS.map(([k,label])=>`
      <label>${label} Notes
        <textarea id="${idPrefix}-${k}" rows="2" placeholder="Notes for ${label}"></textarea>
      </label>
    `).join("");
  }

  function apgarTotal(node){ return (node.appearance|0)+(node.pulse|0)+(node.grimace|0)+(node.activity|0)+(node.respiration|0); }

  function mountApgarBuild(){
    const anchor = document.querySelector('#build [data-section="audio"]');
    if(!anchor || byId('obgyn-apgar-build')) return;
    const block = h(`
      <details id="obgyn-apgar-build" class="builder-section" data-section="apgar" open>
        <summary>
          <span>APGAR</span>
          <div class="display-toggle-row">
            <label class="display-toggle"><input type="checkbox" data-display-key="apgar" checked> APGAR on Play</label>
          </div>
        </summary>
        <div class="section-body">
          <div class="grid">
            <div>
              <div class="badge">1-minute</div>
              <div class="grid" style="margin-top:8px">${apgarSelect('apgar1')}</div>
              <div class="grid" style="margin-top:8px">${apgarNoteInputs('apgar1note')}</div>
            </div>
            <div>
              <div class="badge">5-minutes</div>
              <div class="grid" style="margin-top:8px">${apgarSelect('apgar5')}</div>
              <div class="grid" style="margin-top:8px">${apgarNoteInputs('apgar5note')}</div>
            </div>
          </div>
          <div class="mini" id="apgar-build-totals" style="margin-top:6px"></div>
        </div>
      </details>
    `);
    anchor.parentElement.insertBefore(block, anchor);
    if (window.enhanceBuilderSections){
      window.enhanceBuilderSections(block);
    }
    APGAR_DOMAINS.forEach(([k])=>{
      const s1 = byId(`apgar1-${k}`), s5 = byId(`apgar5-${k}`);
      if(s1){ s1.value = String(scenario.apgar.one[k] ?? 0); s1.onchange = ()=>{ scenario.apgar.one[k]=+s1.value|0; saveSafe(); updateApgarBuildTotals(); renderApgarPlayScores(); }; }
      if(s5){ s5.value = String(scenario.apgar.five[k] ?? 0); s5.onchange = ()=>{ scenario.apgar.five[k]=+s5.value|0; saveSafe(); updateApgarBuildTotals(); renderApgarPlayScores(); }; }
      const n1 = byId(`apgar1note-${k}`), n5 = byId(`apgar5note-${k}`);
      if(n1){
        n1.value = scenario.apgarNotes?.one?.[k] || '';
        const onNote = ()=>{
          scenario.apgarNotes = scenario.apgarNotes || {one:{},five:{}};
          scenario.apgarNotes.one = scenario.apgarNotes.one || {};
          scenario.apgarNotes.one[k] = n1.value;
          saveSafe();
          renderApgarPlayScores();
        };
        n1.addEventListener('input', onNote);
        n1.addEventListener('change', onNote);
      }
      if(n5){
        n5.value = scenario.apgarNotes?.five?.[k] || '';
        const onNote = ()=>{
          scenario.apgarNotes = scenario.apgarNotes || {one:{},five:{}};
          scenario.apgarNotes.five = scenario.apgarNotes.five || {};
          scenario.apgarNotes.five[k] = n5.value;
          saveSafe();
          renderApgarPlayScores();
        };
        n5.addEventListener('input', onNote);
        n5.addEventListener('change', onNote);
      }
    });
    const apToggle = block.querySelector('input[data-display-key="apgar"]');
    if (apToggle){
      apToggle.checked = scenario.displayOnPlay?.apgar !== false;
      apToggle.addEventListener('change', ()=>{ scenario.displayOnPlay.apgar = apToggle.checked; saveSafe(); renderOBPlay(); });
    }
    updateApgarBuildTotals();
  }

  function updateApgarBuildTotals(){
    const t = byId('apgar-build-totals'); if(!t) return;
    t.textContent = `Totals → 1-min: ${apgarTotal(scenario.apgar.one)}/10, 5-min: ${apgarTotal(scenario.apgar.five)}/10`;
  }

  function mountNbVitalsBuild(){
    const vitalsSection = document.querySelector('#build [data-section="vitals"]');
    if (!vitalsSection || byId('obgyn-nb-vitals-build')) return;

    const nb = h(`
      <details id="obgyn-nb-vitals-build" class="builder-section" data-section="nb-vitals" open>
        <summary>
          <span>Newborn Vitals</span>
          <div class="display-toggle-row">
            <label class="display-toggle"><input type="checkbox" data-display-key="nbVitals" checked> NB Monitor on Play</label>
            <label class="display-toggle"><input type="checkbox" data-display-key="nbTreatments" checked> NB Treatments on Play</label>
          </div>
        </summary>
        <div class="section-body">
          <div class="three">
            <label>HR <input id="nb-hr" type="number" value="${scenario.nbVitals.hr}"></label>
            <label>RR <input id="nb-rr" type="number" value="${scenario.nbVitals.rr}"></label>
            <label>SpO₂ <input id="nb-spo2" type="number" step="0.1" value="${scenario.nbVitals.spo2}"></label>
            <label>SBP <input id="nb-sbp" type="number" value="${scenario.nbVitals.sbp}"></label>
            <label>DBP <input id="nb-dbp" type="number" value="${scenario.nbVitals.dbp}"></label>
            <label>CBG <input id="nb-cbg" type="number" value="${scenario.nbVitals.cbg}"></label>
          </div>
          <div class="grid" style="margin-top:10px">
            <label>Pulse Rate <select id="nb-hr-rate"><option>normal</option><option>tachycardic</option><option>bradycardic</option><option>absent</option></select></label>
            <label>Pulse Rhythm <select id="nb-hr-rhythm"><option>regular</option><option>irregular</option><option>absent</option></select></label>
            <label>Pulse Quality <select id="nb-hr-quality"><option>normal</option><option>weak</option><option>thready</option><option>bounding</option><option>absent</option></select></label>
          </div>
          <div class="grid">
            <label>Resp Rate <select id="nb-rr-rate"><option>normal</option><option>tachypneic</option><option>bradypneic</option><option>absent</option></select></label>
            <label>Resp Rhythm <select id="nb-rr-rhythm"><option>regular</option><option>irregular</option><option>absent</option></select></label>
            <label>Resp Quality <select id="nb-rr-quality"><option>normal</option><option>shallow</option><option>labored</option><option>absent</option></select></label>
          </div>
          <div class="grid">
            <label>Skin Color <select id="nb-skin-color"><option>normal</option><option>pink</option><option>pale</option><option>flushed</option><option>cyanotic</option><option>mottled</option><option>jaundiced</option></select></label>
            <label>Skin Temp <select id="nb-skin-temp"><option>warm</option><option>hot</option><option>cool</option><option>cold</option></select></label>
            <label>Skin Moisture <select id="nb-skin-moist"><option>normal</option><option>dry</option><option>moist</option><option>clammy</option><option>diaphoretic</option></select></label>
          </div>
        </div>
      </details>
    `);
    vitalsSection.insertAdjacentElement('afterend', nb);
    if (window.enhanceBuilderSections){
      window.enhanceBuilderSections(nb);
    }

    const map = {
      'nb-hr':'hr','nb-rr':'rr','nb-spo2':'spo2','nb-sbp':'sbp','nb-dbp':'dbp','nb-cbg':'cbg'
    };
    Object.entries(map).forEach(([id,key])=>{
      const el=byId(id); if(!el) return;
      el.addEventListener('input',()=>{ scenario.nbVitals[key]=parseFloat(el.value||0); saveSafe(); });
    });
    const selects = {
      'nb-hr-rate':'hrRate','nb-hr-rhythm':'hrRhythm','nb-hr-quality':'hrQuality',
      'nb-rr-rate':'rrRate','nb-rr-rhythm':'rrRhythm','nb-rr-quality':'rrQuality',
      'nb-skin-color':'skinColor','nb-skin-temp':'skinTemp','nb-skin-moist':'skinMoist'
    };
    Object.entries(selects).forEach(([id,key])=>{
      const el=byId(id); if(!el) return;
      el.value = scenario.nbVitals[key] || el.value;
      el.addEventListener('change',()=>{ scenario.nbVitals[key]=el.value; saveSafe(); });
    });
    nb.querySelectorAll('input[data-display-key],select[data-display-key]').forEach(el=>{
      const key = el.dataset.displayKey;
      if (!key) return;
      el.checked = scenario.displayOnPlay?.[key] !== false;
      el.addEventListener('change', ()=>{ scenario.displayOnPlay[key] = el.type==='checkbox'?el.checked:el.value; saveSafe(); renderOBPlay(); });
    });
  }

  function mountNbTreatmentsBuild(){
    if (byId('nb-tx-section')) return;
    const host = byId('tx-list'); if(!host) return;
    const wrap = h(`
      <details id="nb-tx-section" class="builder-section" data-section="nb-treatments" open>
        <summary>
          <span>Newborn Treatments</span>
        </summary>
        <div class="section-body">
          <div id="nb-tx-list"></div>
          <button id="add-nb-tx" class="btn">Add Newborn Treatment</button>
        </div>
      </details>
    `);
    const hostSection = host.closest('[data-section="treatments"]');
    (hostSection || host.parentElement).insertAdjacentElement('afterend', wrap);
    if (window.enhanceBuilderSections){
      window.enhanceBuilderSections(wrap);
    }
    const add = byId('add-nb-tx');
    if (add){
      add.addEventListener('click', ()=>{
        scenario.nbTreatments.push({ id:`nbtx${Date.now()%1e6}`, label:'NB Tx', mode:'toggle', eff:{}, cap:{}, min:{}, set:{}, priority:0, override:false });
        saveSafe(); drawNbTreatments();
      });
    }
    drawNbTreatments();
  }

  function drawNbTreatments(){
    const host = byId('nb-tx-list'); if(!host) return; host.innerHTML='';
    (scenario.nbTreatments||[]).forEach((tx, i)=>{
      const card = h(`
        <div class="kv">
          <div class="row hdr">
            <label style="flex:2">Label <input class="label" value="${tx.label||''}"></label>
            <label style="flex:1">ID <input class="id" value="${tx.id||''}"></label>
            <label style="flex:1">Mode <select class="mode">
              <option value="toggle" ${tx.mode==='toggle'?'selected':''}>toggle</option>
              <option value="oneShot" ${tx.mode==='oneShot'?'selected':''}>oneShot</option>
            </select></label>
            <label style="flex:0" title="Background color when OFF">
              BG <input class="bg" type="color" value="${tx.bg || '#fafafa'}"
                style="width:46px;padding:0;border:0;background:transparent">
            </label>
            <label style="flex:0" title="Background color when ON">
              BG On <input class="bg-on" type="color" value="${tx.bgOn || tx.bg || '#c7f7c7'}"
                style="width:60px;padding:0;border:0;background:transparent">
            </label>
            <label style="width:90px">Priority <input class="prio" type="number" value="${tx.priority??0}"></label>
            <label style="width:110px">Override <input class="ovr" type="checkbox" ${tx.override?'checked':''}></label>
            <button class="btn danger del">Delete</button>
          </div>
          <div class="body">
            <div class="vital-rows">
              <div class="vital-row head"><div></div><div>Δ/s</div><div>Target</div><div>Max</div><div>Min</div></div>
              ${['hr','rr','spo2','sbp','dbp','cbg'].map(k=>`
                <div class="vital-row">
                  <div class="vlabel">${k.toUpperCase()}</div>
                  <input class="e-${k}" type="number" step="0.01" value="${tx.eff?.[k]||0}">
                  <input class="t-${k}" type="number" step="0.1" value="">
                  <input class="c-${k}" type="number" step="0.1" value="${tx.cap?.[k]??''}" placeholder="none">
                  <input class="m-${k}" type="number" step="0.1" value="${tx.min?.[k]??''}" placeholder="none">
                </div>
              `).join('')}
            </div>
            <div class="inline-line">
              <span class="group-h">Pulse</span>
              <label>Rate <select class="set-hr-rate"><option value="">(no change)</option><option>normal</option><option>tachycardic</option><option>bradycardic</option><option>absent</option></select></label>
              <label>Rhythm <select class="set-hr-rhythm"><option value="">(no change)</option><option>regular</option><option>irregular</option><option>absent</option></select></label>
              <label>Quality <select class="set-hr-quality"><option value="">(no change)</option><option>normal</option><option>weak</option><option>thready</option><option>bounding</option><option>absent</option></select></label>
            </div>
            <div class="inline-line">
              <span class="group-h">Resp</span>
              <label>Rate <select class="set-rr-rate"><option value="">(no change)</option><option>normal</option><option>tachypneic</option><option>bradypneic</option><option>absent</option></select></label>
              <label>Rhythm <select class="set-rr-rhythm"><option value="">(no change)</option><option>regular</option><option>irregular</option><option>absent</option></select></label>
              <label>Quality <select class="set-rr-quality"><option value="">(no change)</option><option>normal</option><option>shallow</option><option>labored</option><option>absent</option></select></label>
            </div>
            <div class="inline-line">
              <span class="group-h">Skin</span>
              <label>Color <select class="set-skin-color"><option value="">(no change)</option><option>normal</option><option>pink</option><option>pale</option><option>flushed</option><option>cyanotic</option><option>mottled</option><option>jaundiced</option></select></label>
              <label>Temp <select class="set-skin-temp"><option value="">(no change)</option><option>warm</option><option>hot</option><option>cool</option><option>cold</option></select></label>
              <label>Moist <select class="set-skin-moist"><option value="">(no change)</option><option>normal</option><option>dry</option><option>moist</option><option>clammy</option><option>diaphoretic</option></select></label>
            </div>
          </div>
        </div>
      `);
      host.appendChild(card);
      const q = (sel) => card.querySelector(sel);
      q('.label').onchange=()=>{ tx.label=q('.label').value; saveSafe(); };
      q('.id').onchange=()=>{ tx.id=q('.id').value; saveSafe(); };
      q('.mode').onchange=()=>{ tx.mode=q('.mode').value; saveSafe(); };
      q('.prio').onchange=()=>{ tx.priority=+q('.prio').value||0; saveSafe(); };
      q('.ovr').onchange=()=>{ tx.override=!!q('.ovr').checked; saveSafe(); };
      const bgInput = q('.bg');
      if (bgInput){
        bgInput.addEventListener('input', ()=>{
          tx.bg = bgInput.value;
          saveSafe();
          buildNbTxButtons();
        });
      }
      const bgOnInput = q('.bg-on');
      if (bgOnInput){
        bgOnInput.addEventListener('input', ()=>{
          tx.bgOn = bgOnInput.value;
          saveSafe();
          buildNbTxButtons();
        });
      }
      q('.del').onclick=()=>{ scenario.nbTreatments.splice(i,1); saveSafe(); drawNbTreatments(); buildNbTxButtons(); };
      ['hr','rr','spo2','sbp','dbp','cbg'].forEach(k=>{
        q('.e-'+k).onchange=()=>{ tx.eff=tx.eff||{}; tx.eff[k]=parseFloat(q('.e-'+k).value||0); saveSafe(); };
        q('.c-'+k).onchange=()=>{ tx.cap=tx.cap||{}; const v=q('.c-'+k).value; tx.cap[k]=v===''?null:parseFloat(v); saveSafe(); };
        q('.m-'+k).onchange=()=>{ tx.min=tx.min||{}; const v=q('.m-'+k).value; tx.min[k]=v===''?null:parseFloat(v); saveSafe(); };
        q('.t-'+k).onchange=()=>{ const v=q('.t-'+k).value; if(v===''){ tx.min=tx.min||{}; tx.cap=tx.cap||{}; delete tx.min[k]; delete tx.cap[k]; } else { const t=parseFloat(v); tx.min=tx.min||{}; tx.cap=tx.cap||{}; tx.min[k]=t; tx.cap[k]=t; } saveSafe(); };
      });
      const setSel = (cls, key)=>{ const el=q('.'+cls); if(!el) return; const init = tx.set?.[key] ?? ""; el.value = init; el.onchange=()=>{ tx.set=tx.set||{}; const v=el.value; if(v==="") delete tx.set[key]; else tx.set[key]=v; saveSafe(); }; };
      setSel('set-hr-rate','hrRate'); setSel('set-hr-rhythm','hrRhythm'); setSel('set-hr-quality','hrQuality');
      setSel('set-rr-rate','rrRate'); setSel('set-rr-rhythm','rrRhythm'); setSel('set-rr-quality','rrQuality');
      setSel('set-skin-color','skinColor'); setSel('set-skin-temp','skinTemp'); setSel('set-skin-moist','skinMoist');
    });
  }

  function relabelMomMonitor(){
    const playPanel = document.querySelector('#play .panel .content'); if(!playPanel) return;
    const h3s = Array.from(playPanel.querySelectorAll('h3'));
    const firstMonitorH3 = h3s.find(h3 => h3.textContent.trim().toLowerCase()==='monitor' && h3.nextElementSibling && h3.nextElementSibling.classList.contains('monitor'));
    if (firstMonitorH3) firstMonitorH3.textContent = "Mom's Vital Signs";
  }

  function mountPlayBlocks(){
    const playPanel = document.querySelector('#play .panel .content'); if(!playPanel) return;

    if(!byId('obgyn-backstory-play')){
      const grid = playPanel.querySelector('.grid');
      const blk = h(`
        <div id="obgyn-backstory-play">
          <div class="divider"></div>
          <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px">
            <div id="p-backstory-wrap">
              <h3>Patient Backstory – Use to answer questions that may be asked</h3>
              <div id="p-backstory" class="content"></div>
            </div>
            <div id="p-talkingpoints-wrap">
              <h3>Inject talking points</h3>
              <div id="p-talkingpoints" class="content"></div>
            </div>
          </div>
        </div>
      `);
      grid.insertAdjacentElement('afterend', blk);
    }

    if(!byId('nb-monitor')){
      const monitorsAfter = playPanel.querySelector('.monitor')?.parentElement || playPanel;
      const blk = h(`
        <div id="nb-monitor-wrap">
          <div class="divider"></div>
          <h3>Newborn Monitor</h3>
          <div class="monitor" id="nb-monitor">
            <div class="kv"><div>HR</div><div class="v" id="np-hr">--</div><div id="np-hr-desc" class="subdesc"></div></div>
            <div class="kv"><div>RR</div><div class="v" id="np-rr">--</div><div id="np-rr-desc" class="subdesc"></div></div>
            <div class="kv compact"><div>SpO₂</div><div class="v" id="np-spo2">--</div></div>
            <div class="kv compact"><div>B/P</div><div class="v" id="np-bp">--/--</div></div>
            <div class="kv compact"><div>CBG</div><div class="v" id="np-cbg">--</div></div>
            <div class="kv compact"><div>Skin</div><div class="v" id="np-skin">--</div></div>
          </div>
          <div id="p-nb-tx-wrap">
            <h3>Newborn Treatments</h3>
            <div id="p-nb-tx-buttons" class="row wide"></div>
          </div>
        </div>
      `);
      monitorsAfter.parentElement.insertBefore(blk, monitorsAfter.nextSibling);
    }

    mountApgarPlayBelowVitals();
    relabelMomMonitor();
  }

  function bulletize(text){
    const items = String(text||'').split(/\n+|[.;]\s+/).map(s=>s.trim()).filter(Boolean);
    return items.length ? `<ul>${items.map(x=>`<li>${x}</li>`).join('')}</ul>` : '—';
  }

  function renderOBPlay(){
    const pb = byId('p-backstory'); if(pb) pb.innerHTML = bulletize(scenario.text.backstory);
    const pt = byId('p-talkingpoints'); if(pt) pt.innerHTML = bulletize(scenario.text.talkingPoints);
    const flags = scenario.displayOnPlay || {};
    const toggle = (id,key)=>{ const el=byId(id); if(el) el.classList.toggle('hidden', flags[key] === false); };
    toggle('p-backstory-wrap','backstory');
    toggle('p-talkingpoints-wrap','talkingPoints');
    toggle('nb-monitor-wrap','nbVitals');
    toggle('p-nb-tx-wrap','nbTreatments');
    toggle('p-apgar-wrap','apgar');
    setNbMonitorValues();
    renderApgarPlayScores();
  }

  function mountApgarPlayBelowVitals(){
    const playPanel = document.querySelector('#play .panel .content'); if(!playPanel) return;
    const old = byId('p-apgar-wrap'); if (old) old.remove();
    const nbWrap = byId('nb-monitor-wrap');
    let anchor = nbWrap || playPanel.querySelector('.monitor')?.parentElement || playPanel;
    const rows = APGAR_DOMAINS.map(([key,label])=>`
            <div class="apgar-row">
              <div class="apgar-label">${label}</div>
              <div class="apgar-score badge" id="apscore-one-${key}">0</div>
              <div class="apgar-note" id="apnote-one-${key}">—</div>
              <div class="apgar-score badge" id="apscore-five-${key}">0</div>
              <div class="apgar-note" id="apnote-five-${key}">—</div>
            </div>
          `).join('');
    const wrap = h(`
      <div id="p-apgar-wrap">
        <div class="divider"></div>
        <h3>APGAR</h3>
        <div class="apgar-table-card">
          <div class="apgar-table">
            <div class="apgar-header">
              <div class="apgar-label">Assessment</div>
              <div class="apgar-score">1-minute</div>
              <div class="apgar-note">Notes</div>
              <div class="apgar-score">5-minutes</div>
              <div class="apgar-note">Notes</div>
            </div>
            ${rows}
            <div class="apgar-footer">
              <div class="apgar-label">Totals</div>
              <div class="apgar-score badge" id="aptotal-one">0/10</div>
              <div class="apgar-note"></div>
              <div class="apgar-score badge" id="aptotal-five">0/10</div>
              <div class="apgar-note"></div>
            </div>
          </div>
        </div>
      </div>
    `);
    anchor.parentElement.insertBefore(wrap, anchor.nextSibling);
    renderApgarPlayScores();
  }

  function renderApgarPlayScores(){
    ['one','five'].forEach(which=>{
      const s = scenario.apgar[which]||{};
      const notes = scenario.apgarNotes?.[which] || {};
      APGAR_DOMAINS.forEach(([k])=>{
        const el = byId(`apscore-${which}-${k}`); if(el) el.textContent = String(s[k]??0);
        const noteEl = byId(`apnote-${which}-${k}`);
        if(noteEl){
          const noteText = (notes[k] || '').trim();
          noteEl.textContent = noteText ? noteText : '—';
        }
      });
      const tot = byId(`aptotal-${which}`); if(tot) tot.textContent = `${apgarTotal(s)}/10`;
    });
  }

  let nbActiveTx = {};
  let nbVitals = {};
  let nbBaseline = {};

  function resetRunNB(){
    if (!scenario.nbVitals) return;
    nbVitals   = {...scenario.nbVitals};
    nbBaseline = {...scenario.nbVitals};
    nbActiveTx = {};
    setNbMonitorValues();
    buildNbTxButtons();
  }

  function setNbMonitorValues(){
    const set=(id,val)=>{ const el=byId(id); if(el) el.textContent=val; };
    set('np-hr',Math.round(nbVitals.hr||0));
    set('np-rr',Math.round(nbVitals.rr||0));
    set('np-spo2',(nbVitals.spo2??0).toFixed(1));
    set('np-bp',Math.round(nbVitals.sbp||0)+"/"+Math.round(nbVitals.dbp||0));
    set('np-cbg',Math.round(nbVitals.cbg??0));
    const hrDesc = `Rate: ${scenario.nbVitals.hrRate||'normal'} | Rhythm: ${scenario.nbVitals.hrRhythm||'regular'} | Quality: ${scenario.nbVitals.hrQuality||'normal'}`;
    const rrDesc = `Rate: ${scenario.nbVitals.rrRate||'normal'} | Rhythm: ${scenario.nbVitals.rrRhythm||'regular'} | Quality: ${scenario.nbVitals.rrQuality||'normal'}`;
    const hrD=byId('np-hr-desc'); if(hrD) hrD.textContent = hrDesc;
    const rrD=byId('np-rr-desc'); if(rrD) rrD.textContent = rrDesc;
    const skin=byId('np-skin'); if(skin) skin.textContent = `${scenario.nbVitals.skinColor||'--'} / ${scenario.nbVitals.skinTemp||'--'} / ${scenario.nbVitals.skinMoist||'--'}`;
  }

  function applyEffectsPerSecondNB(){
    const vitKeys = ['hr','rr','spo2','sbp','dbp','cbg'];
    const getBase = (k)=>{ const base = (nbBaseline && typeof nbBaseline[k] === 'number') ? nbBaseline[k] : Number(scenario.nbVitals?.[k] ?? 0); return Number.isFinite(base)?base:0; };
    vitKeys.forEach(k=>{ if(nbVitals[k]==null) nbVitals[k]=getBase(k); });
    const activeList = (scenario.nbTreatments||[])
      .filter(tx => nbActiveTx[tx.id]?.on)
      .sort((a,b)=>(b.priority||0)-(a.priority||0));
    const delta = Object.fromEntries(vitKeys.map(k=>[k,0]));
    const minCap = Object.fromEntries(vitKeys.map(k=>[k,null]));
    const maxCap = Object.fromEntries(vitKeys.map(k=>[k,null]));
    for (const tx of activeList){
      const eff=tx.eff||{};
      const mn=tx.min||{};
      const cp=tx.cap||{};
      for (const k of vitKeys){
        if (delta[k] === 0){ const d = Number(eff[k] || 0); if (d) delta[k] = d; }
        if (minCap[k] == null && mn[k] != null && mn[k] !== '') minCap[k] = Number(mn[k]);
        if (maxCap[k] == null && cp[k] != null && cp[k] !== '') maxCap[k] = Number(cp[k]);
      }
    }
    for (const k of vitKeys){
      let v = Number(nbVitals[k]);
      if (delta[k] !== 0){
        v += delta[k];
      } else {
        const base = getBase(k);
        const diff = base - v;
        if (Math.abs(diff) >= 0.5){ v += Math.sign(diff) * 0.5; }
        else { v = base; }
      }
      if (minCap[k] != null && v < minCap[k]) v = minCap[k];
      if (maxCap[k] != null && v > maxCap[k]) v = maxCap[k];
      if (k === 'spo2'){ if (v < 0) v = 0; if (v > 100) v = 100; }
      if (k === 'hr')  { if (v < 0) v = 0; if (v > 240) v = 240; }
      if (k === 'rr')  { if (v < 0) v = 0; if (v > 60)  v = 60;  }
      if (k === 'sbp') { if (v < 0) v = 0; if (v > 260) v = 260; }
      if (k === 'dbp') { if (v < 0) v = 0; if (v > 160) v = 160; }
      if (k === 'cbg') { if (v < 0) v = 0; if (v > 600) v = 600; }
      nbVitals[k] = v;
    }
    const descKeys=['hrRate','hrRhythm','hrQuality','rrRate','rrRhythm','rrQuality','skinColor','skinTemp','skinMoist'];
    const desc={}; descKeys.forEach(k=>desc[k]=nbBaseline[k]);
    for (const tx of (scenario.nbTreatments||[])){
      const st=nbActiveTx[tx.id]; if(!st||!st.on) continue;
      const set=tx.set||{};
      for (const k of descKeys){ if (set[k]!=null) desc[k]=set[k]; }
    }
    for (const k of descKeys) scenario.nbVitals[k]=desc[k];
  }

  function buildNbTxButtons(){
    function mount(id){
      const host = byId(id); if(!host) return; host.innerHTML='';
      (scenario.nbTreatments||[]).forEach(tx=>{
        const b=document.createElement('button');
        b.className='btn';
        b.textContent=tx.label||tx.id;
        const getOn = ()=>tx.bgOn || tx.bg || '';
        const getOff = ()=>tx.bg || '';
        const hasCustomColors = !!(tx.bg || tx.bgOn);
        const pickTextColor = (hex)=>{
          if (!hex || typeof hex !== 'string') return '';
          const match = hex.trim().match(/^#?([0-9a-f]{6})$/i);
          if (!match) return '';
          const raw = match[1];
          const r = parseInt(raw.slice(0,2),16);
          const g = parseInt(raw.slice(2,4),16);
          const b = parseInt(raw.slice(4,6),16);
          const luminance = (0.2126*r + 0.7152*g + 0.0722*b) / 255;
          return luminance > 0.6 ? '#111' : '#fff';
        };

        const applyState = (isOn)=>{
          b.classList.toggle('tx-on', isOn);
          if (hasCustomColors){
            b.classList.remove('success');
            const tone = isOn ? getOn() : getOff();
            if (tone){
              b.style.background = tone;
              b.style.borderColor = tone;
              const textColor = pickTextColor(tone);
              b.style.color = textColor || '';
            } else {
              b.style.background = '';
              b.style.borderColor = '';
              b.style.color = '';
            }
          } else {
            b.style.background = '';
            b.style.borderColor = '';
            b.style.color = '';
            b.classList.toggle('success', isOn);
          }
        };

        const isOnInit = !!(nbActiveTx[tx.id] && nbActiveTx[tx.id].on);
        applyState(isOnInit);

        b.addEventListener('click', ()=>{
          nbActiveTx[tx.id] = nbActiveTx[tx.id] || {on:false, done:false};
          if (tx.mode==='toggle'){
            nbActiveTx[tx.id].on = !nbActiveTx[tx.id].on;
          }
          else {
            nbActiveTx[tx.id].on = true;
            nbActiveTx[tx.id].done = false;
          }
          applyState(!!nbActiveTx[tx.id].on);
          saveSafe();
        });
        host.appendChild(b);
      });
    }
    mount('p-nb-tx-buttons');
  }

  function monkeyPatchCore(){
    if(!window._origResetRun && typeof resetRun==="function"){
      window._origResetRun = resetRun;
      resetRun = function(){ window._origResetRun(); resetRunNB(); };
    }
    if(!window._origTick && typeof tick==="function"){
      window._origTick = tick;
      tick = function(){ window._origTick(); applyEffectsPerSecondNB(); setNbMonitorValues(); };
    }
    if(!window._origRenderAll && typeof renderAll==="function"){
      window._origRenderAll = renderAll;
      renderAll = function(){ window._origRenderAll(); renderOBPlay(); };
    }
  }

  function boot(){
    try{
      ensureScenarioExtensions();
      mountBackstoryBuild();
      mountApgarBuild();
      mountNbVitalsBuild();
      mountNbTreatmentsBuild();
      mountPlayBlocks();
      buildNbTxButtons();
      monkeyPatchCore();
      resetRunNB();
      renderOBPlay();
      hydrateBuilderInputs();
      saveSafe();
    }catch(e){ console.error('[OBGYN add-on]', e); }
  }

  function readyCheck(){
    if (document.readyState === 'complete' || document.readyState === 'interactive'){
      if (byId('build') && byId('play')) { boot(); }
      else setTimeout(readyCheck, 150);
    } else {
      document.addEventListener('DOMContentLoaded', readyCheck, {once:true});
    }
  }
  setTimeout(readyCheck, 120);
})();
</script>



<!-- Global reset (Clear All) -->
<script>
(function(){
  "use strict";

  const byId = (id)=>document.getElementById(id);

  function defaultScenario(){
    return JSON.parse(JSON.stringify(DEFAULT_SCENARIO));
  }

  function mountButton(){
    if (byId('clear-all-btn')) return;
    const bar = document.querySelector('header .title');
    if (!bar) return;
    const btn = document.createElement('button');
    btn.id = 'clear-all-btn';
    btn.className = 'btn danger';
    btn.style.marginLeft = '12px';
    btn.textContent = 'Clear All';
    btn.addEventListener('click', ()=>{
      if (!confirm('Reset scenario to defaults?')) return;
      scenario = defaultScenario();
      localStorage.setItem('emtScenarioRunnerV27', JSON.stringify(scenario));
      hydrateBuilderInputs();
      load();
      resetRun();
    });
    bar.appendChild(btn);
  }

  function boot(){
    mountButton();
  }

  if (document.readyState==='complete' || document.readyState==='interactive') boot();
  else document.addEventListener('DOMContentLoaded', boot, {once:true});
})();
</script>

<script>
(function(){
  "use strict";
  const byId = (id)=>document.getElementById(id);

  function ensureField(){
    window.scenario = window.scenario || {};
    scenario.text = scenario.text || {};
    if (scenario.text.hospitalEta == null) scenario.text.hospitalEta = "—";
  }

  function addStyles(){
    if (byId('eta-style')) return;
    const st = document.createElement('style');
    st.id = 'eta-style';
    st.textContent = `
      .eta-pill{ cursor:default }
    `;
    document.head.appendChild(st);
  }

  function renderEta(){
    ensureField();
    const pill = byId('eta-pill');
    if (pill) pill.textContent = scenario.text.hospitalEta || '—';
  }

  function patchRenderAll(){
    if (window._origRenderAll_eta || typeof window.renderAll !== 'function') return;
    window._origRenderAll_eta = window.renderAll;
    window.renderAll = function(){
      window._origRenderAll_eta();
      try{ renderEta(); }catch{}
    };
  }

  function boot(){
    ensureField();
    addStyles();
    renderEta();
    patchRenderAll();
  }

  if (document.readyState === 'complete' || document.readyState === 'interactive') boot();
  else document.addEventListener('DOMContentLoaded', boot, {once:true});
})();
</script>
</body>
</html>
